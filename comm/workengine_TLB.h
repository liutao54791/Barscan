// ************************************************************************ //
// WARNING                                                                    
// -------                                                                    
// The types declared in this file were generated from data read from a       
// Type Library. If this type library is explicitly or indirectly (via        
// another type library referring to this type library) re-imported, or the   
// 'Refresh' command of the Type Library Editor activated while editing the   
// Type Library, the contents of this file will be regenerated and all        
// manual modifications will be lost.                                         
// ************************************************************************ //

// $Rev: 52393 $
// File generated on 2017/9/26 9:57:22 from Type Library described below.

// ************************************************************************  //
// Type Lib: D:\WorkSpace\BarcodeScanner\workengine.dll (1)
// LIBID: {1A540555-EE58-45CB-9CC9-2883344B4E77}
// LCID: 0
// Helpfile: 
// HelpString: 
// DepndLst: 
//   (1) v2.0 stdole, (C:\Windows\system32\stdole2.tlb)
// SYS_KIND: SYS_WIN32
// ************************************************************************ //
#ifndef   workengine_TLBH
#define   workengine_TLBH

#pragma option push -b -a4 -w-inl -w-8118

#if !defined(__UTILCLS_H)
#include <utilcls.h>
#endif
#if !defined(__UTILCLS_H_VERSION) || (__UTILCLS_H_VERSION < 0x0700)
//
// The code generated by the TLIBIMP utility or the Import|TypeLibrary 
// and Import|ActiveX feature of C++Builder rely on specific versions of
// the header file UTILCLS.H found in the INCLUDE\VCL directory. If an 
// older version of the file is detected, you probably need an update/patch.
//
#error "This file requires a newer version of the header UTILCLS.H" \
       "You need to apply an update/patch to your copy of C++Builder"
#endif
#include <olectl.h>
#include <ocidl.h>
#if defined(USING_ATLVCL) || defined(USING_ATL)
#if !defined(__TLB_NO_EVENT_WRAPPERS)
#include <atl/atlmod.h>
#endif
#endif

#include <StdVCL.hpp>

typedef TComInterface<System::Win::Stdvcl::IStrings> IStringsPtr;
typedef TComInterface<System::Win::Stdvcl::IStringsDisp> IStringsDispPtr;

namespace Workengine_tlb
{

// *********************************************************************//
// HelpString: 
// Version:    1.0
// *********************************************************************//


// *********************************************************************//
// GUIDS declared in the TypeLibrary. Following prefixes are used:        
//   Type Libraries     : LIBID_xxxx                                      
//   CoClasses          : CLSID_xxxx                                      
//   DISPInterfaces     : DIID_xxxx                                       
//   Non-DISP interfaces: IID_xxxx                                        
// *********************************************************************//
extern __declspec (package) const GUID LIBID_workengine;
extern __declspec (package) const GUID IID_IWorkUnitEngine;
extern __declspec (package) const GUID IID_IWorkUnit;
extern __declspec (package) const GUID DIID_IWorkUnitEngineEvent;
extern __declspec (package) const GUID DIID_IWorkUnitEvent;
extern __declspec (package) const GUID CLSID_ResourceUploader;
extern __declspec (package) const GUID CLSID_CommandExecutor;
extern __declspec (package) const GUID CLSID_ErrorHandler;
extern __declspec (package) const GUID CLSID_ResourceAllocator;
extern __declspec (package) const GUID CLSID_WorkUnitEngine;
extern __declspec (package) const GUID IID_ICommonMessage;
extern __declspec (package) const GUID CLSID_CommonMessage;

// *********************************************************************//
// Forward declaration of types defined in TypeLibrary                    
// *********************************************************************//
interface DECLSPEC_UUID("{98AF0EC1-6EFB-413D-95E4-612F6A07748A}") IWorkUnitEngine;
typedef TComInterface<IWorkUnitEngine, &IID_IWorkUnitEngine> IWorkUnitEnginePtr;

interface DECLSPEC_UUID("{6034406A-84BD-40CA-8AE9-C3B44A21B4B6}") IWorkUnit;
typedef TComInterface<IWorkUnit, &IID_IWorkUnit> IWorkUnitPtr;

interface DECLSPEC_UUID("{1E867724-D0D4-4EEB-B0CB-EF030AE0EA1E}") IWorkUnitEngineEvent;
typedef TComInterface<IWorkUnitEngineEvent, &DIID_IWorkUnitEngineEvent> IWorkUnitEngineEventPtr;

interface DECLSPEC_UUID("{4B4A48DC-6577-4B70-BF57-713FFDD0E758}") IWorkUnitEvent;
typedef TComInterface<IWorkUnitEvent, &DIID_IWorkUnitEvent> IWorkUnitEventPtr;

interface DECLSPEC_UUID("{57F3DF25-70C7-4BCD-B711-AB71400F8F9B}") ICommonMessage;
typedef TComInterface<ICommonMessage, &IID_ICommonMessage> ICommonMessagePtr;


// *********************************************************************//
// Declaration of CoClasses defined in Type Library                       
// (NOTE: Here we map each CoClass to its Default Interface)              
//                                                                        
// The LIBID_OF_ macro(s) map a LIBID_OF_CoClassName to the GUID of this  
// TypeLibrary. It simplifies the updating of macros when CoClass name    
// change.                                                                
// *********************************************************************//
typedef IWorkUnit ResourceUploader;
typedef IWorkUnitPtr ResourceUploaderPtr;
typedef IWorkUnit CommandExecutor;
typedef IWorkUnitPtr CommandExecutorPtr;
typedef IWorkUnit ErrorHandler;
typedef IWorkUnitPtr ErrorHandlerPtr;
typedef IWorkUnit ResourceAllocator;
typedef IWorkUnitPtr ResourceAllocatorPtr;
typedef IWorkUnitEngine WorkUnitEngine;
typedef IWorkUnitEnginePtr WorkUnitEnginePtr;
typedef ICommonMessage CommonMessage;
typedef ICommonMessagePtr CommonMessagePtr;

#define LIBID_OF_ResourceUploader (&LIBID_workengine)
#define LIBID_OF_CommandExecutor (&LIBID_workengine)
#define LIBID_OF_ErrorHandler (&LIBID_workengine)
#define LIBID_OF_ResourceAllocator (&LIBID_workengine)
#define LIBID_OF_WorkUnitEngine (&LIBID_workengine)
#define LIBID_OF_CommonMessage (&LIBID_workengine)
// *********************************************************************//
// Interface: IWorkUnitEngine
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {98AF0EC1-6EFB-413D-95E4-612F6A07748A}
// *********************************************************************//
interface IWorkUnitEngine  : public IDispatch
{
public:
  virtual HRESULT STDMETHODCALLTYPE RegisterWorkUnit(Workengine_tlb::IWorkUnit** pwuWorkUnit/*[in]*/) = 0; // [201]
  virtual HRESULT STDMETHODCALLTYPE Start(void) = 0; // [202]
  virtual HRESULT STDMETHODCALLTYPE Stop(void) = 0; // [203]
  virtual HRESULT STDMETHODCALLTYPE UnregisterWorkUnit(Workengine_tlb::IWorkUnit* pwuWorkUnit/*[in]*/) = 0; // [204]
  virtual HRESULT STDMETHODCALLTYPE ProcessMessage(BSTR NetAddress/*[in]*/, 
                                                   Workengine_tlb::ICommonMessage* CommonMessage/*[in]*/) = 0; // [205]

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)



#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: IWorkUnit
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {6034406A-84BD-40CA-8AE9-C3B44A21B4B6}
// *********************************************************************//
interface IWorkUnit  : public IDispatch
{
public:
  virtual HRESULT STDMETHODCALLTYPE HandleMessage(Workengine_tlb::ICommonMessage* pmSour/*[in]*/, 
                                                  Workengine_tlb::ICommonMessage** pmDest/*[out,retval]*/) = 0; // [201]
  virtual HRESULT STDMETHODCALLTYPE get_Type(long* Value/*[out,retval]*/) = 0; // [203]
  virtual HRESULT STDMETHODCALLTYPE set_Type(long Value/*[in]*/) = 0; // [203]
  virtual HRESULT STDMETHODCALLTYPE Init(void) = 0; // [204]
  virtual HRESULT STDMETHODCALLTYPE get_PlanId(long* Value/*[out,retval]*/) = 0; // [205]
  virtual HRESULT STDMETHODCALLTYPE set_PlanId(long Value/*[in]*/) = 0; // [205]
  virtual HRESULT STDMETHODCALLTYPE SetSuccessor(Workengine_tlb::IWorkUnit** pwuSuccessor/*[in]*/) = 0; // [202]
  virtual HRESULT STDMETHODCALLTYPE GetSuccessor(Workengine_tlb::IWorkUnit** pwuSuccessor/*[out,retval]*/) = 0; // [206]

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  Workengine_tlb::ICommonMessage* __fastcall HandleMessage(Workengine_tlb::ICommonMessage* pmSour/*[in]*/)
  {
    Workengine_tlb::ICommonMessage* pmDest = 0;
    OLECHECK(this->HandleMessage(pmSour, (Workengine_tlb::ICommonMessage**)&pmDest));
    return pmDest;
  }

  long __fastcall get_Type(void)
  {
    long Value;
    OLECHECK(this->get_Type((long*)&Value));
    return Value;
  }

  long __fastcall get_PlanId(void)
  {
    long Value;
    OLECHECK(this->get_PlanId((long*)&Value));
    return Value;
  }

  Workengine_tlb::IWorkUnit* __fastcall GetSuccessor(void)
  {
    Workengine_tlb::IWorkUnit* pwuSuccessor = 0;
    OLECHECK(this->GetSuccessor((Workengine_tlb::IWorkUnit**)&pwuSuccessor));
    return pwuSuccessor;
  }


  __property   long            Type = {read = get_Type, write = set_Type};
  __property   long            PlanId = {read = get_PlanId, write = set_PlanId};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: IWorkUnitEngineEvent
// Flags:     (4096) Dispatchable
// GUID:      {1E867724-D0D4-4EEB-B0CB-EF030AE0EA1E}
// *********************************************************************//
interface IWorkUnitEngineEvent : public TDispWrapper<IDispatch>
{
  HRESULT __fastcall OnError(long nErrorCode/*[in]*/)
  {
    _TDispID _dispid(/* OnError */ DISPID(201));
    TAutoArgs<1> _args;
    _args[1] = nErrorCode /*[VT_I4:0]*/;
    return OleFunction(_dispid, _args);
  }

  HRESULT __fastcall OnMessageReceived(BSTR NetAddress/*[in]*/, LPDISPATCH pcmMessage/*[in]*/)
  {
    _TDispID _dispid(/* OnMessageReceived */ DISPID(202));
    TAutoArgs<2> _args;
    _args[1] = NetAddress /*[VT_BSTR:0]*/;
    _args[2] = pcmMessage /*[VT_DISPATCH:0]*/;
    return OleFunction(_dispid, _args);
  }

  HRESULT __fastcall OnMessageSent(BSTR NetAddress/*[in]*/, LPDISPATCH pcmMessage/*[in]*/)
  {
    _TDispID _dispid(/* OnMessageSent */ DISPID(203));
    TAutoArgs<2> _args;
    _args[1] = NetAddress /*[VT_BSTR:0]*/;
    _args[2] = pcmMessage /*[VT_DISPATCH:0]*/;
    return OleFunction(_dispid, _args);
  }


};
// *********************************************************************//
// Interface: IWorkUnitEvent
// Flags:     (4096) Dispatchable
// GUID:      {4B4A48DC-6577-4B70-BF57-713FFDD0E758}
// *********************************************************************//
interface IWorkUnitEvent : public TDispWrapper<IDispatch>
{
  HRESULT __fastcall OnError(BSTR ProcedureId/*[in]*/, long ErrorCode/*[in]*/, 
                             BSTR ErrorMessage/*[in]*/)
  {
    _TDispID _dispid(/* OnError */ DISPID(201));
    TAutoArgs<3> _args;
    _args[1] = ProcedureId /*[VT_BSTR:0]*/;
    _args[2] = ErrorCode /*[VT_I4:0]*/;
    _args[3] = ErrorMessage /*[VT_BSTR:0]*/;
    return OleFunction(_dispid, _args);
  }


};
// *********************************************************************//
// Interface: ICommonMessage
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {57F3DF25-70C7-4BCD-B711-AB71400F8F9B}
// *********************************************************************//
interface ICommonMessage  : public IDispatch
{
public:
  virtual HRESULT STDMETHODCALLTYPE get_XmlMessage(BSTR* Value/*[out,retval]*/) = 0; // [201]
  virtual HRESULT STDMETHODCALLTYPE set_XmlMessage(BSTR Value/*[in]*/) = 0; // [201]
  virtual HRESULT STDMETHODCALLTYPE GetNodeText(BSTR strPath/*[in]*/, BSTR* strText/*[out,retval]*/) = 0; // [202]
  virtual HRESULT STDMETHODCALLTYPE SetNodeText(BSTR strPath/*[in]*/, BSTR strTest/*[in]*/) = 0; // [203]

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  BSTR __fastcall get_XmlMessage(void)
  {
    BSTR Value = 0;
    OLECHECK(this->get_XmlMessage((BSTR*)&Value));
    return Value;
  }

  BSTR __fastcall GetNodeText(BSTR strPath/*[in]*/)
  {
    BSTR strText = 0;
    OLECHECK(this->GetNodeText(strPath, (BSTR*)&strText));
    return strText;
  }


  __property   BSTR            XmlMessage = {read = get_XmlMessage, write = set_XmlMessage};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)
// *********************************************************************//
// SmartIntf: TCOMIWorkUnitEngine
// Interface: IWorkUnitEngine
// *********************************************************************//
template <class T /* IWorkUnitEngine */ >
class TCOMIWorkUnitEngineT : public TComInterface<IWorkUnitEngine>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMIWorkUnitEngineT() {}
  TCOMIWorkUnitEngineT(IWorkUnitEngine *intf, bool addRef = false) : TComInterface<IWorkUnitEngine>(intf, addRef) {}
  TCOMIWorkUnitEngineT(const TCOMIWorkUnitEngineT& src) : TComInterface<IWorkUnitEngine>(src) {}
  TCOMIWorkUnitEngineT& operator=(const TCOMIWorkUnitEngineT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall RegisterWorkUnit(Workengine_tlb::IWorkUnit** pwuWorkUnit/*[in]*/);
  HRESULT         __fastcall Start(void);
  HRESULT         __fastcall Stop(void);
  HRESULT         __fastcall UnregisterWorkUnit(Workengine_tlb::IWorkUnit* pwuWorkUnit/*[in]*/);
  HRESULT         __fastcall ProcessMessage(BSTR NetAddress/*[in]*/, 
                                            Workengine_tlb::ICommonMessage* CommonMessage/*[in]*/);

};
typedef TCOMIWorkUnitEngineT<IWorkUnitEngine> TCOMIWorkUnitEngine;

// *********************************************************************//
// DispIntf:  IWorkUnitEngine
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {98AF0EC1-6EFB-413D-95E4-612F6A07748A}
// *********************************************************************//
template<class T>
class IWorkUnitEngineDispT : public TAutoDriver<IWorkUnitEngine>
{
public:
  IWorkUnitEngineDispT(){}

  IWorkUnitEngineDispT(IWorkUnitEngine *pintf)
  {
    TAutoDriver<IWorkUnitEngine>::Bind(pintf, false);
  }

  IWorkUnitEngineDispT(IWorkUnitEnginePtr pintf)
  {
    TAutoDriver<IWorkUnitEngine>::Bind(pintf, true);
  }

  IWorkUnitEngineDispT& operator=(IWorkUnitEngine *pintf)
  {
    TAutoDriver<IWorkUnitEngine>::Bind(pintf, false);
    return *this;
  }

  IWorkUnitEngineDispT& operator=(IWorkUnitEnginePtr pintf)
  {
    TAutoDriver<IWorkUnitEngine>::Bind(pintf, true);
    return *this;
  }

  HRESULT BindDefault()
  {
    return OLECHECK(Bind(CLSID_WorkUnitEngine));
  }

  HRESULT BindRunning()
  {
    return BindToActive(CLSID_WorkUnitEngine);
  }

  HRESULT         __fastcall RegisterWorkUnit(Workengine_tlb::IWorkUnit** pwuWorkUnit/*[in]*/);
  HRESULT         __fastcall Start();
  HRESULT         __fastcall Stop();
  HRESULT         __fastcall UnregisterWorkUnit(Workengine_tlb::IWorkUnit* pwuWorkUnit/*[in]*/);
  HRESULT         __fastcall ProcessMessage(BSTR NetAddress/*[in]*/, 
                                            Workengine_tlb::ICommonMessage* CommonMessage/*[in]*/);

};
typedef IWorkUnitEngineDispT<IWorkUnitEngine> IWorkUnitEngineDisp;

// *********************************************************************//
// SmartIntf: TCOMIWorkUnit
// Interface: IWorkUnit
// *********************************************************************//
template <class T /* IWorkUnit */ >
class TCOMIWorkUnitT : public TComInterface<IWorkUnit>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMIWorkUnitT() {}
  TCOMIWorkUnitT(IWorkUnit *intf, bool addRef = false) : TComInterface<IWorkUnit>(intf, addRef) {}
  TCOMIWorkUnitT(const TCOMIWorkUnitT& src) : TComInterface<IWorkUnit>(src) {}
  TCOMIWorkUnitT& operator=(const TCOMIWorkUnitT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall HandleMessage(Workengine_tlb::ICommonMessage* pmSour/*[in]*/, 
                                           Workengine_tlb::ICommonMessage** pmDest/*[out,retval]*/);
  Workengine_tlb::ICommonMessage* __fastcall HandleMessage(Workengine_tlb::ICommonMessage* pmSour/*[in]*/);
  HRESULT         __fastcall get_Type(long* Value/*[out,retval]*/);
  long            __fastcall get_Type(void);
  HRESULT         __fastcall set_Type(long Value/*[in]*/);
  HRESULT         __fastcall Init(void);
  HRESULT         __fastcall get_PlanId(long* Value/*[out,retval]*/);
  long            __fastcall get_PlanId(void);
  HRESULT         __fastcall set_PlanId(long Value/*[in]*/);
  HRESULT         __fastcall SetSuccessor(Workengine_tlb::IWorkUnit** pwuSuccessor/*[in]*/);
  HRESULT         __fastcall GetSuccessor(Workengine_tlb::IWorkUnit** pwuSuccessor/*[out,retval]*/);
  Workengine_tlb::IWorkUnit* __fastcall GetSuccessor(void);

  __property   long            Type = {read = get_Type, write = set_Type};
  __property   long            PlanId = {read = get_PlanId, write = set_PlanId};
};
typedef TCOMIWorkUnitT<IWorkUnit> TCOMIWorkUnit;

// *********************************************************************//
// DispIntf:  IWorkUnit
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {6034406A-84BD-40CA-8AE9-C3B44A21B4B6}
// *********************************************************************//
template<class T>
class IWorkUnitDispT : public TAutoDriver<IWorkUnit>
{
public:
  IWorkUnitDispT(){}

  IWorkUnitDispT(IWorkUnit *pintf)
  {
    TAutoDriver<IWorkUnit>::Bind(pintf, false);
  }

  IWorkUnitDispT(IWorkUnitPtr pintf)
  {
    TAutoDriver<IWorkUnit>::Bind(pintf, true);
  }

  IWorkUnitDispT& operator=(IWorkUnit *pintf)
  {
    TAutoDriver<IWorkUnit>::Bind(pintf, false);
    return *this;
  }

  IWorkUnitDispT& operator=(IWorkUnitPtr pintf)
  {
    TAutoDriver<IWorkUnit>::Bind(pintf, true);
    return *this;
  }

  HRESULT BindDefault()
  {
    return OLECHECK(Bind(CLSID_ResourceUploader));
  }

  HRESULT BindRunning()
  {
    return BindToActive(CLSID_ResourceUploader);
  }

  HRESULT         __fastcall HandleMessage(Workengine_tlb::ICommonMessage* pmSour/*[in]*/, 
                                           Workengine_tlb::ICommonMessage** pmDest/*[out,retval]*/);
  Workengine_tlb::ICommonMessage* __fastcall HandleMessage(Workengine_tlb::ICommonMessage* pmSour/*[in]*/);
  HRESULT         __fastcall get_Type(long* Value/*[out,retval]*/);
  long            __fastcall get_Type(void);
  HRESULT         __fastcall set_Type(long Value/*[in]*/);
  HRESULT         __fastcall Init();
  HRESULT         __fastcall get_PlanId(long* Value/*[out,retval]*/);
  long            __fastcall get_PlanId(void);
  HRESULT         __fastcall set_PlanId(long Value/*[in]*/);
  HRESULT         __fastcall SetSuccessor(Workengine_tlb::IWorkUnit** pwuSuccessor/*[in]*/);
  HRESULT         __fastcall GetSuccessor(Workengine_tlb::IWorkUnit** pwuSuccessor/*[out,retval]*/);
  Workengine_tlb::IWorkUnit* __fastcall GetSuccessor(void);

  __property   long            Type = {read = get_Type, write = set_Type};
  __property   long            PlanId = {read = get_PlanId, write = set_PlanId};
};
typedef IWorkUnitDispT<IWorkUnit> IWorkUnitDisp;

// *********************************************************************//
// DispIntf:  IWorkUnitEngineEvent
// Flags:     (4096) Dispatchable
// GUID:      {1E867724-D0D4-4EEB-B0CB-EF030AE0EA1E}
// *********************************************************************//
template <class T>
class IWorkUnitEngineEventDispT : public TAutoDriver<IWorkUnitEngineEvent>
{
public:
  IWorkUnitEngineEventDispT(){}

  void Attach(LPUNKNOWN punk)
  { m_Dispatch = static_cast<T*>(punk); }

  HRESULT         __fastcall OnError(long nErrorCode/*[in]*/);
  HRESULT         __fastcall OnMessageReceived(BSTR NetAddress/*[in]*/, 
                                               LPDISPATCH pcmMessage/*[in]*/);
  HRESULT         __fastcall OnMessageSent(BSTR NetAddress/*[in]*/, LPDISPATCH pcmMessage/*[in]*/);

};
typedef IWorkUnitEngineEventDispT<IWorkUnitEngineEvent> IWorkUnitEngineEventDisp;

// *********************************************************************//
// DispIntf:  IWorkUnitEvent
// Flags:     (4096) Dispatchable
// GUID:      {4B4A48DC-6577-4B70-BF57-713FFDD0E758}
// *********************************************************************//
template <class T>
class IWorkUnitEventDispT : public TAutoDriver<IWorkUnitEvent>
{
public:
  IWorkUnitEventDispT(){}

  void Attach(LPUNKNOWN punk)
  { m_Dispatch = static_cast<T*>(punk); }

  HRESULT         __fastcall OnError(BSTR ProcedureId/*[in]*/, long ErrorCode/*[in]*/, 
                                     BSTR ErrorMessage/*[in]*/);

};
typedef IWorkUnitEventDispT<IWorkUnitEvent> IWorkUnitEventDisp;

// *********************************************************************//
// SmartIntf: TCOMICommonMessage
// Interface: ICommonMessage
// *********************************************************************//
template <class T /* ICommonMessage */ >
class TCOMICommonMessageT : public TComInterface<ICommonMessage>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMICommonMessageT() {}
  TCOMICommonMessageT(ICommonMessage *intf, bool addRef = false) : TComInterface<ICommonMessage>(intf, addRef) {}
  TCOMICommonMessageT(const TCOMICommonMessageT& src) : TComInterface<ICommonMessage>(src) {}
  TCOMICommonMessageT& operator=(const TCOMICommonMessageT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall get_XmlMessage(BSTR* Value/*[out,retval]*/);
  BSTR            __fastcall get_XmlMessage(void);
  HRESULT         __fastcall set_XmlMessage(BSTR Value/*[in]*/);
  HRESULT         __fastcall GetNodeText(BSTR strPath/*[in]*/, BSTR* strText/*[out,retval]*/);
  BSTR            __fastcall GetNodeText(BSTR strPath/*[in]*/);
  HRESULT         __fastcall SetNodeText(BSTR strPath/*[in]*/, BSTR strTest/*[in]*/);

  __property   BSTR            XmlMessage = {read = get_XmlMessage, write = set_XmlMessage};
};
typedef TCOMICommonMessageT<ICommonMessage> TCOMICommonMessage;

// *********************************************************************//
// DispIntf:  ICommonMessage
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {57F3DF25-70C7-4BCD-B711-AB71400F8F9B}
// *********************************************************************//
template<class T>
class ICommonMessageDispT : public TAutoDriver<ICommonMessage>
{
public:
  ICommonMessageDispT(){}

  ICommonMessageDispT(ICommonMessage *pintf)
  {
    TAutoDriver<ICommonMessage>::Bind(pintf, false);
  }

  ICommonMessageDispT(ICommonMessagePtr pintf)
  {
    TAutoDriver<ICommonMessage>::Bind(pintf, true);
  }

  ICommonMessageDispT& operator=(ICommonMessage *pintf)
  {
    TAutoDriver<ICommonMessage>::Bind(pintf, false);
    return *this;
  }

  ICommonMessageDispT& operator=(ICommonMessagePtr pintf)
  {
    TAutoDriver<ICommonMessage>::Bind(pintf, true);
    return *this;
  }

  HRESULT BindDefault()
  {
    return OLECHECK(Bind(CLSID_CommonMessage));
  }

  HRESULT BindRunning()
  {
    return BindToActive(CLSID_CommonMessage);
  }

  HRESULT         __fastcall get_XmlMessage(BSTR* Value/*[out,retval]*/);
  BSTR            __fastcall get_XmlMessage(void);
  HRESULT         __fastcall set_XmlMessage(BSTR Value/*[in]*/);
  HRESULT         __fastcall GetNodeText(BSTR strPath/*[in]*/, BSTR* strText/*[out,retval]*/);
  BSTR            __fastcall GetNodeText(BSTR strPath/*[in]*/);
  HRESULT         __fastcall SetNodeText(BSTR strPath/*[in]*/, BSTR strTest/*[in]*/);

  __property   BSTR            XmlMessage = {read = get_XmlMessage, write = set_XmlMessage};
};
typedef ICommonMessageDispT<ICommonMessage> ICommonMessageDisp;

// *********************************************************************//
// SmartIntf: TCOMIWorkUnitEngine
// Interface: IWorkUnitEngine
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMIWorkUnitEngineT<T>::RegisterWorkUnit(Workengine_tlb::IWorkUnit** pwuWorkUnit/*[in]*/)
{
  return (*this)->RegisterWorkUnit(pwuWorkUnit);
}

template <class T> HRESULT __fastcall
TCOMIWorkUnitEngineT<T>::Start(void)
{
  return (*this)->Start();
}

template <class T> HRESULT __fastcall
TCOMIWorkUnitEngineT<T>::Stop(void)
{
  return (*this)->Stop();
}

template <class T> HRESULT __fastcall
TCOMIWorkUnitEngineT<T>::UnregisterWorkUnit(Workengine_tlb::IWorkUnit* pwuWorkUnit/*[in]*/)
{
  return (*this)->UnregisterWorkUnit(pwuWorkUnit);
}

template <class T> HRESULT __fastcall
TCOMIWorkUnitEngineT<T>::ProcessMessage(BSTR NetAddress/*[in]*/, 
                                        Workengine_tlb::ICommonMessage* CommonMessage/*[in]*/)
{
  return (*this)->ProcessMessage(NetAddress, CommonMessage);
}

// *********************************************************************//
// DispIntf:  IWorkUnitEngine
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {98AF0EC1-6EFB-413D-95E4-612F6A07748A}
// *********************************************************************//
template <class T> HRESULT __fastcall
IWorkUnitEngineDispT<T>::RegisterWorkUnit(Workengine_tlb::IWorkUnit** pwuWorkUnit/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("RegisterWorkUnit"), DISPID(201));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH*)(Workengine_tlb::IWorkUnit**)pwuWorkUnit /*[VT_USERDEFINED:2]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
IWorkUnitEngineDispT<T>::Start()
{
  _TDispID _dispid(*this, OLETEXT("Start"), DISPID(202));
  return OleFunction(_dispid);
}

template <class T> HRESULT __fastcall
IWorkUnitEngineDispT<T>::Stop()
{
  _TDispID _dispid(*this, OLETEXT("Stop"), DISPID(203));
  return OleFunction(_dispid);
}

template <class T> HRESULT __fastcall
IWorkUnitEngineDispT<T>::UnregisterWorkUnit(Workengine_tlb::IWorkUnit* pwuWorkUnit/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("UnregisterWorkUnit"), DISPID(204));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH)(Workengine_tlb::IWorkUnit*)pwuWorkUnit /*[VT_USERDEFINED:1]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
IWorkUnitEngineDispT<T>::ProcessMessage(BSTR NetAddress/*[in]*/, 
                                        Workengine_tlb::ICommonMessage* CommonMessage/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("ProcessMessage"), DISPID(205));
  TAutoArgs<2> _args;
  _args[1] = NetAddress /*[VT_BSTR:0]*/;
  _args[2] = (LPDISPATCH)(Workengine_tlb::ICommonMessage*)CommonMessage /*[VT_USERDEFINED:1]*/;
  return OleFunction(_dispid, _args);
}

// *********************************************************************//
// SmartIntf: TCOMIWorkUnit
// Interface: IWorkUnit
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMIWorkUnitT<T>::HandleMessage(Workengine_tlb::ICommonMessage* pmSour/*[in]*/, 
                                 Workengine_tlb::ICommonMessage** pmDest/*[out,retval]*/)
{
  return (*this)->HandleMessage(pmSour, pmDest);
}

template <class T> Workengine_tlb::ICommonMessage* __fastcall
TCOMIWorkUnitT<T>::HandleMessage(Workengine_tlb::ICommonMessage* pmSour/*[in]*/)
{
  Workengine_tlb::ICommonMessage* pmDest;
  OLECHECK(this->HandleMessage(pmSour/*[in]*/, (Workengine_tlb::ICommonMessage**)&pmDest));
  return pmDest;
}

template <class T> HRESULT __fastcall
TCOMIWorkUnitT<T>::get_Type(long* Value/*[out,retval]*/)
{
  return (*this)->get_Type(Value);
}

template <class T> long __fastcall
TCOMIWorkUnitT<T>::get_Type(void)
{
  long Value;
  OLECHECK(this->get_Type((long*)&Value));
  return Value;
}

template <class T> HRESULT __fastcall
TCOMIWorkUnitT<T>::set_Type(long Value/*[in]*/)
{
  return (*this)->set_Type(Value);
}

template <class T> HRESULT __fastcall
TCOMIWorkUnitT<T>::Init(void)
{
  return (*this)->Init();
}

template <class T> HRESULT __fastcall
TCOMIWorkUnitT<T>::get_PlanId(long* Value/*[out,retval]*/)
{
  return (*this)->get_PlanId(Value);
}

template <class T> long __fastcall
TCOMIWorkUnitT<T>::get_PlanId(void)
{
  long Value;
  OLECHECK(this->get_PlanId((long*)&Value));
  return Value;
}

template <class T> HRESULT __fastcall
TCOMIWorkUnitT<T>::set_PlanId(long Value/*[in]*/)
{
  return (*this)->set_PlanId(Value);
}

template <class T> HRESULT __fastcall
TCOMIWorkUnitT<T>::SetSuccessor(Workengine_tlb::IWorkUnit** pwuSuccessor/*[in]*/)
{
  return (*this)->SetSuccessor(pwuSuccessor);
}

template <class T> HRESULT __fastcall
TCOMIWorkUnitT<T>::GetSuccessor(Workengine_tlb::IWorkUnit** pwuSuccessor/*[out,retval]*/)
{
  return (*this)->GetSuccessor(pwuSuccessor);
}

template <class T> Workengine_tlb::IWorkUnit* __fastcall
TCOMIWorkUnitT<T>::GetSuccessor(void)
{
  Workengine_tlb::IWorkUnit* pwuSuccessor;
  OLECHECK(this->GetSuccessor((Workengine_tlb::IWorkUnit**)&pwuSuccessor));
  return pwuSuccessor;
}

// *********************************************************************//
// DispIntf:  IWorkUnit
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {6034406A-84BD-40CA-8AE9-C3B44A21B4B6}
// *********************************************************************//
template <class T> HRESULT __fastcall
IWorkUnitDispT<T>::HandleMessage(Workengine_tlb::ICommonMessage* pmSour/*[in]*/, 
                                 Workengine_tlb::ICommonMessage** pmDest/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("HandleMessage"), DISPID(201));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH)(Workengine_tlb::ICommonMessage*)pmSour /*[VT_USERDEFINED:1]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Workengine_tlb::ICommonMessage**)pmDest /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Workengine_tlb::ICommonMessage* __fastcall
IWorkUnitDispT<T>::HandleMessage(Workengine_tlb::ICommonMessage* pmSour/*[in]*/)
{
  Workengine_tlb::ICommonMessage* pmDest;
  this->HandleMessage(pmSour, (Workengine_tlb::ICommonMessage**)&pmDest);
  return pmDest;
}

template <class T> HRESULT __fastcall
IWorkUnitDispT<T>::get_Type(long* Value/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Type"), DISPID(203));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Value /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
IWorkUnitDispT<T>::get_Type(void)
{
  long Value;
  this->get_Type((long*)&Value);
  return Value;
}

template <class T> HRESULT __fastcall
IWorkUnitDispT<T>::set_Type(long Value/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Type"), DISPID(203));
  TAutoArgs<1> _args;
  _args[1] = Value /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IWorkUnitDispT<T>::Init()
{
  _TDispID _dispid(*this, OLETEXT("Init"), DISPID(204));
  return OleFunction(_dispid);
}

template <class T> HRESULT __fastcall
IWorkUnitDispT<T>::get_PlanId(long* Value/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("PlanId"), DISPID(205));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Value /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
IWorkUnitDispT<T>::get_PlanId(void)
{
  long Value;
  this->get_PlanId((long*)&Value);
  return Value;
}

template <class T> HRESULT __fastcall
IWorkUnitDispT<T>::set_PlanId(long Value/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("PlanId"), DISPID(205));
  TAutoArgs<1> _args;
  _args[1] = Value /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IWorkUnitDispT<T>::SetSuccessor(Workengine_tlb::IWorkUnit** pwuSuccessor/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("SetSuccessor"), DISPID(202));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH*)(Workengine_tlb::IWorkUnit**)pwuSuccessor /*[VT_USERDEFINED:2]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
IWorkUnitDispT<T>::GetSuccessor(Workengine_tlb::IWorkUnit** pwuSuccessor/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetSuccessor"), DISPID(206));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Workengine_tlb::IWorkUnit**)pwuSuccessor /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Workengine_tlb::IWorkUnit* __fastcall
IWorkUnitDispT<T>::GetSuccessor(void)
{
  Workengine_tlb::IWorkUnit* pwuSuccessor;
  this->GetSuccessor((Workengine_tlb::IWorkUnit**)&pwuSuccessor);
  return pwuSuccessor;
}

// *********************************************************************//
// DispIntf:  IWorkUnitEngineEvent
// Flags:     (4096) Dispatchable
// GUID:      {1E867724-D0D4-4EEB-B0CB-EF030AE0EA1E}
// *********************************************************************//
template <class T> HRESULT __fastcall
IWorkUnitEngineEventDispT<T>::OnError(long nErrorCode/*[in]*/)
{
  _TDispID _dispid(/* OnError */ DISPID(201));
  TAutoArgs<1> _args;
  _args[1] = nErrorCode /*[VT_I4:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
IWorkUnitEngineEventDispT<T>::OnMessageReceived(BSTR NetAddress/*[in]*/, 
                                                LPDISPATCH pcmMessage/*[in]*/)
{
  _TDispID _dispid(/* OnMessageReceived */ DISPID(202));
  TAutoArgs<2> _args;
  _args[1] = NetAddress /*[VT_BSTR:0]*/;
  _args[2] = pcmMessage /*[VT_DISPATCH:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
IWorkUnitEngineEventDispT<T>::OnMessageSent(BSTR NetAddress/*[in]*/, LPDISPATCH pcmMessage/*[in]*/)
{
  _TDispID _dispid(/* OnMessageSent */ DISPID(203));
  TAutoArgs<2> _args;
  _args[1] = NetAddress /*[VT_BSTR:0]*/;
  _args[2] = pcmMessage /*[VT_DISPATCH:0]*/;
  return OleFunction(_dispid, _args);
}

// *********************************************************************//
// DispIntf:  IWorkUnitEvent
// Flags:     (4096) Dispatchable
// GUID:      {4B4A48DC-6577-4B70-BF57-713FFDD0E758}
// *********************************************************************//
template <class T> HRESULT __fastcall
IWorkUnitEventDispT<T>::OnError(BSTR ProcedureId/*[in]*/, long ErrorCode/*[in]*/, 
                                BSTR ErrorMessage/*[in]*/)
{
  _TDispID _dispid(/* OnError */ DISPID(201));
  TAutoArgs<3> _args;
  _args[1] = ProcedureId /*[VT_BSTR:0]*/;
  _args[2] = ErrorCode /*[VT_I4:0]*/;
  _args[3] = ErrorMessage /*[VT_BSTR:0]*/;
  return OleFunction(_dispid, _args);
}

// *********************************************************************//
// SmartIntf: TCOMICommonMessage
// Interface: ICommonMessage
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMICommonMessageT<T>::get_XmlMessage(BSTR* Value/*[out,retval]*/)
{
  return (*this)->get_XmlMessage(Value);
}

template <class T> BSTR __fastcall
TCOMICommonMessageT<T>::get_XmlMessage(void)
{
  BSTR Value = 0;
  OLECHECK(this->get_XmlMessage((BSTR*)&Value));
  return Value;
}

template <class T> HRESULT __fastcall
TCOMICommonMessageT<T>::set_XmlMessage(BSTR Value/*[in]*/)
{
  return (*this)->set_XmlMessage(Value);
}

template <class T> HRESULT __fastcall
TCOMICommonMessageT<T>::GetNodeText(BSTR strPath/*[in]*/, BSTR* strText/*[out,retval]*/)
{
  return (*this)->GetNodeText(strPath, strText);
}

template <class T> BSTR __fastcall
TCOMICommonMessageT<T>::GetNodeText(BSTR strPath/*[in]*/)
{
  BSTR strText = 0;
  OLECHECK(this->GetNodeText(strPath/*[in]*/, (BSTR*)&strText));
  return strText;
}

template <class T> HRESULT __fastcall
TCOMICommonMessageT<T>::SetNodeText(BSTR strPath/*[in]*/, BSTR strTest/*[in]*/)
{
  return (*this)->SetNodeText(strPath, strTest);
}

// *********************************************************************//
// DispIntf:  ICommonMessage
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {57F3DF25-70C7-4BCD-B711-AB71400F8F9B}
// *********************************************************************//
template <class T> HRESULT __fastcall
ICommonMessageDispT<T>::get_XmlMessage(BSTR* Value/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("XmlMessage"), DISPID(201));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Value /*[VT_BSTR:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> BSTR __fastcall
ICommonMessageDispT<T>::get_XmlMessage(void)
{
  BSTR Value;
  this->get_XmlMessage((BSTR*)&Value);
  return Value;
}

template <class T> HRESULT __fastcall
ICommonMessageDispT<T>::set_XmlMessage(BSTR Value/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("XmlMessage"), DISPID(201));
  TAutoArgs<1> _args;
  _args[1] = Value /*[VT_BSTR:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ICommonMessageDispT<T>::GetNodeText(BSTR strPath/*[in]*/, BSTR* strText/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetNodeText"), DISPID(202));
  TAutoArgs<1> _args;
  _args[1] = strPath /*[VT_BSTR:0]*/;
  return OutRetValSetterPtr(strText /*[VT_BSTR:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> BSTR __fastcall
ICommonMessageDispT<T>::GetNodeText(BSTR strPath/*[in]*/)
{
  BSTR strText;
  this->GetNodeText(strPath, (BSTR*)&strText);
  return strText;
}

template <class T> HRESULT __fastcall
ICommonMessageDispT<T>::SetNodeText(BSTR strPath/*[in]*/, BSTR strTest/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("SetNodeText"), DISPID(203));
  TAutoArgs<2> _args;
  _args[1] = strPath /*[VT_BSTR:0]*/;
  _args[2] = strTest /*[VT_BSTR:0]*/;
  return OleFunction(_dispid, _args);
}

// *********************************************************************//
// The following typedefs expose classes (named CoCoClassName) that       
// provide static Create() and CreateRemote(LPWSTR machineName) methods   
// for creating an instance of an exposed object. These functions can     
// be used by client wishing to automate CoClasses exposed by this        
// typelibrary.                                                           
// *********************************************************************//

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : ResourceUploader
// Interface: TCOMIWorkUnit
// *********************************************************************//
typedef TCoClassCreatorT<TCOMIWorkUnit, IWorkUnit, &CLSID_ResourceUploader, &IID_IWorkUnit> CoResourceUploader;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : CommandExecutor
// Interface: TCOMIWorkUnit
// *********************************************************************//
typedef TCoClassCreatorT<TCOMIWorkUnit, IWorkUnit, &CLSID_CommandExecutor, &IID_IWorkUnit> CoCommandExecutor;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : ErrorHandler
// Interface: TCOMIWorkUnit
// *********************************************************************//
typedef TCoClassCreatorT<TCOMIWorkUnit, IWorkUnit, &CLSID_ErrorHandler, &IID_IWorkUnit> CoErrorHandler;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : ResourceAllocator
// Interface: TCOMIWorkUnit
// *********************************************************************//
typedef TCoClassCreatorT<TCOMIWorkUnit, IWorkUnit, &CLSID_ResourceAllocator, &IID_IWorkUnit> CoResourceAllocator;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : WorkUnitEngine
// Interface: TCOMIWorkUnitEngine
// *********************************************************************//
typedef TCoClassCreatorT<TCOMIWorkUnitEngine, IWorkUnitEngine, &CLSID_WorkUnitEngine, &IID_IWorkUnitEngine> CoWorkUnitEngine;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : CommonMessage
// Interface: TCOMICommonMessage
// *********************************************************************//
typedef TCoClassCreatorT<TCOMICommonMessage, ICommonMessage, &CLSID_CommonMessage, &IID_ICommonMessage> CoCommonMessage;
#endif  //   __TLB_NO_INTERFACE_WRAPPERS


#if !defined(__TLB_NO_EVENT_WRAPPERS) && defined(USING_ATLVCL)
// *********************************************************************//
// CONNECTIONPOINT/EVENT PROXY
// CoClass         : ResourceUploader
// Event Interface : IWorkUnitEvent
// *********************************************************************//
template <class T>
class TEvents_ResourceUploader : public IConnectionPointImpl<T,
                                                 &DIID_IWorkUnitEvent,
#if !defined(_TLB_DYNAMIC_CONNECTIONPOINT_ARRAY)
                                                 CComUnkArray<CONNECTIONPOINT_ARRAY_SIZE> >
#else
                                                 CComDynamicArray>
#endif
{
public:
  HRESULT         Fire_OnError(BSTR ProcedureId, long ErrorCode, BSTR ErrorMessage);
protected:
  IWorkUnitEventDisp m_EventIntfObj;
};

template <class T> HRESULT
TEvents_ResourceUploader<T>::Fire_OnError(BSTR ProcedureId, long ErrorCode, BSTR ErrorMessage)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.OnError(ProcedureId, ErrorCode, ErrorMessage);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
  return S_OK;
}

// *********************************************************************//
// CONNECTIONPOINT/EVENT PROXY
// CoClass         : CommandExecutor
// Event Interface : IWorkUnitEvent
// *********************************************************************//
template <class T>
class TEvents_CommandExecutor : public IConnectionPointImpl<T,
                                                 &DIID_IWorkUnitEvent,
#if !defined(_TLB_DYNAMIC_CONNECTIONPOINT_ARRAY)
                                                 CComUnkArray<CONNECTIONPOINT_ARRAY_SIZE> >
#else
                                                 CComDynamicArray>
#endif
{
public:
  HRESULT         Fire_OnError(BSTR ProcedureId, long ErrorCode, BSTR ErrorMessage);
protected:
  IWorkUnitEventDisp m_EventIntfObj;
};

template <class T> HRESULT
TEvents_CommandExecutor<T>::Fire_OnError(BSTR ProcedureId, long ErrorCode, BSTR ErrorMessage)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.OnError(ProcedureId, ErrorCode, ErrorMessage);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
  return S_OK;
}

// *********************************************************************//
// CONNECTIONPOINT/EVENT PROXY
// CoClass         : ErrorHandler
// Event Interface : IWorkUnitEvent
// *********************************************************************//
template <class T>
class TEvents_ErrorHandler : public IConnectionPointImpl<T,
                                                 &DIID_IWorkUnitEvent,
#if !defined(_TLB_DYNAMIC_CONNECTIONPOINT_ARRAY)
                                                 CComUnkArray<CONNECTIONPOINT_ARRAY_SIZE> >
#else
                                                 CComDynamicArray>
#endif
{
public:
  HRESULT         Fire_OnError(BSTR ProcedureId, long ErrorCode, BSTR ErrorMessage);
protected:
  IWorkUnitEventDisp m_EventIntfObj;
};

template <class T> HRESULT
TEvents_ErrorHandler<T>::Fire_OnError(BSTR ProcedureId, long ErrorCode, BSTR ErrorMessage)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.OnError(ProcedureId, ErrorCode, ErrorMessage);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
  return S_OK;
}

// *********************************************************************//
// CONNECTIONPOINT/EVENT PROXY
// CoClass         : ResourceAllocator
// Event Interface : IWorkUnitEvent
// *********************************************************************//
template <class T>
class TEvents_ResourceAllocator : public IConnectionPointImpl<T,
                                                 &DIID_IWorkUnitEvent,
#if !defined(_TLB_DYNAMIC_CONNECTIONPOINT_ARRAY)
                                                 CComUnkArray<CONNECTIONPOINT_ARRAY_SIZE> >
#else
                                                 CComDynamicArray>
#endif
{
public:
  HRESULT         Fire_OnError(BSTR ProcedureId, long ErrorCode, BSTR ErrorMessage);
protected:
  IWorkUnitEventDisp m_EventIntfObj;
};

template <class T> HRESULT
TEvents_ResourceAllocator<T>::Fire_OnError(BSTR ProcedureId, long ErrorCode, BSTR ErrorMessage)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.OnError(ProcedureId, ErrorCode, ErrorMessage);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
  return S_OK;
}

// *********************************************************************//
// CONNECTIONPOINT/EVENT PROXY
// CoClass         : WorkUnitEngine
// Event Interface : IWorkUnitEngineEvent
// *********************************************************************//
template <class T>
class TEvents_WorkUnitEngine : public IConnectionPointImpl<T,
                                                 &DIID_IWorkUnitEngineEvent,
#if !defined(_TLB_DYNAMIC_CONNECTIONPOINT_ARRAY)
                                                 CComUnkArray<CONNECTIONPOINT_ARRAY_SIZE> >
#else
                                                 CComDynamicArray>
#endif
{
public:
  HRESULT         Fire_OnError(long nErrorCode);
  HRESULT         Fire_OnMessageReceived(BSTR NetAddress, LPDISPATCH pcmMessage);
  HRESULT         Fire_OnMessageSent(BSTR NetAddress, LPDISPATCH pcmMessage);
protected:
  IWorkUnitEngineEventDisp m_EventIntfObj;
};

template <class T> HRESULT
TEvents_WorkUnitEngine<T>::Fire_OnError(long nErrorCode)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.OnError(nErrorCode);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
  return S_OK;
}

template <class T> HRESULT
TEvents_WorkUnitEngine<T>::Fire_OnMessageReceived(BSTR NetAddress, LPDISPATCH pcmMessage)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.OnMessageReceived(NetAddress, pcmMessage);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
  return S_OK;
}

template <class T> HRESULT
TEvents_WorkUnitEngine<T>::Fire_OnMessageSent(BSTR NetAddress, LPDISPATCH pcmMessage)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.OnMessageSent(NetAddress, pcmMessage);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
  return S_OK;
}

#endif    //   __TLB_NO_EVENT_WRAPPERS

#if !defined(__TLB_NO_EVENT_WRAPPERS) && defined(USING_DAX)
// *********************************************************************//
// CONNECTIONPOINT/EVENT PROXY
// CoClass         : ResourceUploader
// Event Interface : IWorkUnitEvent
// *********************************************************************//
template <typename T>
class IResourceUploader_EventsDispatcher : public IUnknown
{
public:
  HRESULT Fire_OnError(BSTR ProcedureId, long ErrorCode, BSTR ErrorMessage)
  {
    IWorkUnitEventDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.OnError(ProcedureId, ErrorCode, ErrorMessage);
      }
    }
    return S_OK;
  }

};

// *********************************************************************//
// CONNECTIONPOINT/EVENT PROXY
// CoClass         : CommandExecutor
// Event Interface : IWorkUnitEvent
// *********************************************************************//
template <typename T>
class ICommandExecutor_EventsDispatcher : public IUnknown
{
public:
  HRESULT Fire_OnError(BSTR ProcedureId, long ErrorCode, BSTR ErrorMessage)
  {
    IWorkUnitEventDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.OnError(ProcedureId, ErrorCode, ErrorMessage);
      }
    }
    return S_OK;
  }

};

// *********************************************************************//
// CONNECTIONPOINT/EVENT PROXY
// CoClass         : ErrorHandler
// Event Interface : IWorkUnitEvent
// *********************************************************************//
template <typename T>
class IErrorHandler_EventsDispatcher : public IUnknown
{
public:
  HRESULT Fire_OnError(BSTR ProcedureId, long ErrorCode, BSTR ErrorMessage)
  {
    IWorkUnitEventDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.OnError(ProcedureId, ErrorCode, ErrorMessage);
      }
    }
    return S_OK;
  }

};

// *********************************************************************//
// CONNECTIONPOINT/EVENT PROXY
// CoClass         : ResourceAllocator
// Event Interface : IWorkUnitEvent
// *********************************************************************//
template <typename T>
class IResourceAllocator_EventsDispatcher : public IUnknown
{
public:
  HRESULT Fire_OnError(BSTR ProcedureId, long ErrorCode, BSTR ErrorMessage)
  {
    IWorkUnitEventDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.OnError(ProcedureId, ErrorCode, ErrorMessage);
      }
    }
    return S_OK;
  }

};

// *********************************************************************//
// CONNECTIONPOINT/EVENT PROXY
// CoClass         : WorkUnitEngine
// Event Interface : IWorkUnitEngineEvent
// *********************************************************************//
template <typename T>
class IWorkUnitEngine_EventsDispatcher : public IUnknown
{
public:
  HRESULT Fire_OnError(long nErrorCode)
  {
    IWorkUnitEngineEventDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.OnError(nErrorCode);
      }
    }
    return S_OK;
  }

  HRESULT Fire_OnMessageReceived(BSTR NetAddress, LPDISPATCH pcmMessage)
  {
    IWorkUnitEngineEventDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.OnMessageReceived(NetAddress, pcmMessage);
      }
    }
    return S_OK;
  }

  HRESULT Fire_OnMessageSent(BSTR NetAddress, LPDISPATCH pcmMessage)
  {
    IWorkUnitEngineEventDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.OnMessageSent(NetAddress, pcmMessage);
      }
    }
    return S_OK;
  }

};

#endif    //   __TLB_NO_EVENT_WRAPPERS

};     // namespace Workengine_tlb

#if !defined(NO_IMPLICIT_NAMESPACE_USE)
using  namespace Workengine_tlb;
#endif

#pragma option pop

#endif // workengine_TLBH
