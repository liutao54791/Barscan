// ************************************************************************ //
// WARNING                                                                    
// -------                                                                    
// The types declared in this file were generated from data read from a       
// Type Library. If this type library is explicitly or indirectly (via        
// another type library referring to this type library) re-imported, or the   
// 'Refresh' command of the Type Library Editor activated while editing the   
// Type Library, the contents of this file will be regenerated and all        
// manual modifications will be lost.                                         
// ************************************************************************ //

// $Rev: 52393 $
// File generated on 2017/10/17 14:18:17 from Type Library described below.

// ************************************************************************  //
// Type Lib: D:\WorkSpace\BarcodeScanner\Comm.dll (1)
// LIBID: {85F4871C-26E9-42E7-A054-67C79CAF3A9D}
// LCID: 0
// Helpfile: 
// HelpString: 
// DepndLst: 
//   (1) v2.0 stdole, (C:\Windows\system32\stdole2.tlb)
// SYS_KIND: SYS_WIN32
// ************************************************************************ //
#ifndef   CommLib_TLBH
#define   CommLib_TLBH

#pragma option push -b -a4 -w-inl -w-8118

#if !defined(__UTILCLS_H)
#include <utilcls.h>
#endif
#if !defined(__UTILCLS_H_VERSION) || (__UTILCLS_H_VERSION < 0x0700)
//
// The code generated by the TLIBIMP utility or the Import|TypeLibrary 
// and Import|ActiveX feature of C++Builder rely on specific versions of
// the header file UTILCLS.H found in the INCLUDE\VCL directory. If an 
// older version of the file is detected, you probably need an update/patch.
//
#error "This file requires a newer version of the header UTILCLS.H" \
       "You need to apply an update/patch to your copy of C++Builder"
#endif
#include <olectl.h>
#include <ocidl.h>
#if defined(USING_ATLVCL) || defined(USING_ATL)
#if !defined(__TLB_NO_EVENT_WRAPPERS)
#include <atl/atlmod.h>
#endif
#endif

#include <StdVCL.hpp>

typedef TComInterface<System::Win::Stdvcl::IStrings> IStringsPtr;
typedef TComInterface<System::Win::Stdvcl::IStringsDisp> IStringsDispPtr;

namespace Commlib_tlb
{

// *********************************************************************//
// HelpString: 
// Version:    1.0
// *********************************************************************//


// *********************************************************************//
// GUIDS declared in the TypeLibrary. Following prefixes are used:        
//   Type Libraries     : LIBID_xxxx                                      
//   CoClasses          : CLSID_xxxx                                      
//   DISPInterfaces     : DIID_xxxx                                       
//   Non-DISP interfaces: IID_xxxx                                        
// *********************************************************************//
extern __declspec (package) const GUID LIBID_CommLib;
extern __declspec (package) const GUID DIID__ISerialPortEvents;
extern __declspec (package) const GUID IID_ISerialPort;
extern __declspec (package) const GUID CLSID_SerialPort;
extern __declspec (package) const GUID GUID___MIDL_ISerialPort_0001;
extern __declspec (package) const GUID GUID_EParityMode;
extern __declspec (package) const GUID GUID___MIDL_ISerialPort_0002;
extern __declspec (package) const GUID GUID_EStopBits;
extern __declspec (package) const GUID DIID__ITcpClientSocketEvents;
extern __declspec (package) const GUID IID_ITcpClientSocket;
extern __declspec (package) const GUID CLSID_TcpClientSocket;

// *********************************************************************//
// Forward declaration of types defined in TypeLibrary                    
// *********************************************************************//
enum class    __MIDL_ISerialPort_0001;
enum class    __MIDL_ISerialPort_0002;
interface DECLSPEC_UUID("{00718A57-81E0-48E9-B9EB-36E40C640180}") _ISerialPortEvents;
typedef TComInterface<_ISerialPortEvents, &DIID__ISerialPortEvents> _ISerialPortEventsPtr;

interface DECLSPEC_UUID("{FDEC8B1F-1004-4DF5-AAAA-6A99D6AE3C00}") ISerialPort;
typedef TComInterface<ISerialPort, &IID_ISerialPort> ISerialPortPtr;

interface DECLSPEC_UUID("{23689734-AB52-4C8F-BAF2-796D446D4491}") _ITcpClientSocketEvents;
typedef TComInterface<_ITcpClientSocketEvents, &DIID__ITcpClientSocketEvents> _ITcpClientSocketEventsPtr;

interface DECLSPEC_UUID("{95340789-564B-4833-A8EC-4D69E58194BD}") ITcpClientSocket;
typedef TComInterface<ITcpClientSocket, &IID_ITcpClientSocket> ITcpClientSocketPtr;


// *********************************************************************//
// Declaration of CoClasses defined in Type Library                       
// (NOTE: Here we map each CoClass to its Default Interface)              
//                                                                        
// The LIBID_OF_ macro(s) map a LIBID_OF_CoClassName to the GUID of this  
// TypeLibrary. It simplifies the updating of macros when CoClass name    
// change.                                                                
// *********************************************************************//
typedef ISerialPort SerialPort;
typedef ISerialPortPtr SerialPortPtr;
typedef ITcpClientSocket TcpClientSocket;
typedef ITcpClientSocketPtr TcpClientSocketPtr;

#define LIBID_OF_SerialPort (&LIBID_CommLib)
#define LIBID_OF_TcpClientSocket (&LIBID_CommLib)

// *********************************************************************//
// Declaration of Aliases defined in Type Library                         
// *********************************************************************//
typedef Commlib_tlb::__MIDL_ISerialPort_0001 EParityMode;
typedef Commlib_tlb::__MIDL_ISerialPort_0002 EStopBits;

// *********************************************************************//
// Declaration of Enumerations defined in Type Library                    
// *********************************************************************//
enum class __MIDL_ISerialPort_0001
{
  pmNoParity = 0, 
  pmOdd = 1, 
  pmEven = 2
};

enum class __MIDL_ISerialPort_0002
{
  sb1Bits = 0, 
  sb1_5Bits = 1, 
  sb2Bits = 2
};

// *********************************************************************//
// Interface: _ISerialPortEvents
// Flags:     (4096) Dispatchable
// GUID:      {00718A57-81E0-48E9-B9EB-36E40C640180}
// *********************************************************************//
interface _ISerialPortEvents : public TDispWrapper<IDispatch>
{
  void __fastcall OnRead(LPUNKNOWN Sender/*[in]*/, unsigned_char* pbBuffer/*[in]*/, 
                         unsigned_long nLength/*[in]*/)
  {
    _TDispID _dispid(/* OnRead */ DISPID(1));
    TAutoArgs<3> _args;
    _args[1] = Sender /*[VT_UNKNOWN:0]*/;
    _args[2] = pbBuffer /*[VT_UI1:1]*/;
    _args[3] = nLength /*[VT_UI4:0]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall OnStatus(LPUNKNOWN Sender/*[in]*/, unsigned_long nErrorCode/*[in]*/, 
                           BSTR strErrorInfo/*[in]*/)
  {
    _TDispID _dispid(/* OnStatus */ DISPID(2));
    TAutoArgs<3> _args;
    _args[1] = Sender /*[VT_UNKNOWN:0]*/;
    _args[2] = nErrorCode /*[VT_UI4:0]*/;
    _args[3] = strErrorInfo /*[VT_BSTR:0]*/;
    OleProcedure(_dispid, _args);
  }


};
// *********************************************************************//
// Interface: ISerialPort
// Flags:     (4544) Dual NonExtensible OleAutomation Dispatchable
// GUID:      {FDEC8B1F-1004-4DF5-AAAA-6A99D6AE3C00}
// *********************************************************************//
interface ISerialPort  : public IDispatch
{
public:
  // [1] port id
  virtual HRESULT STDMETHODCALLTYPE get_PortId(unsigned_long* pVal/*[out,retval]*/) = 0;
  // [1] port id
  virtual HRESULT STDMETHODCALLTYPE set_PortId(unsigned_long pVal/*[in]*/) = 0;
  // [2] baudrate
  virtual HRESULT STDMETHODCALLTYPE get_Baudrate(unsigned_long* pVal/*[out,retval]*/) = 0;
  // [2] baudrate
  virtual HRESULT STDMETHODCALLTYPE set_Baudrate(unsigned_long pVal/*[in]*/) = 0;
  // [3] parity mode
  virtual HRESULT STDMETHODCALLTYPE get_ParityMode(Commlib_tlb::EParityMode* pVal/*[out,retval]*/) = 0;
  // [3] parity mode
  virtual HRESULT STDMETHODCALLTYPE set_ParityMode(Commlib_tlb::EParityMode pVal/*[in]*/) = 0;
  // [4] byte size
  virtual HRESULT STDMETHODCALLTYPE get_ByteSize(unsigned_char* pVal/*[out,retval]*/) = 0;
  // [4] byte size
  virtual HRESULT STDMETHODCALLTYPE set_ByteSize(unsigned_char pVal/*[in]*/) = 0;
  // [5] stop bit count
  virtual HRESULT STDMETHODCALLTYPE get_StopBits(Commlib_tlb::EStopBits* pVal/*[out,retval]*/) = 0;
  // [5] stop bit count
  virtual HRESULT STDMETHODCALLTYPE set_StopBits(Commlib_tlb::EStopBits pVal/*[in]*/) = 0;
  // [6] open the serial port
  virtual HRESULT STDMETHODCALLTYPE Open(void) = 0;
  // [7] Close the serial port
  virtual HRESULT STDMETHODCALLTYPE Close(void) = 0;
  // [8] send buffer
  virtual HRESULT STDMETHODCALLTYPE SendBuffer(unsigned_char* pbBuffer/*[in]*/, 
                                               unsigned_long nDataLen/*[in]*/) = 0;
  // [9] is port active or not
  virtual HRESULT STDMETHODCALLTYPE IsActive(VARIANT_BOOL* pbActive/*[out,retval]*/) = 0;
  // [10] port tag
  virtual HRESULT STDMETHODCALLTYPE get_Tag(long* pVal/*[out,retval]*/) = 0;
  // [10] port tag
  virtual HRESULT STDMETHODCALLTYPE set_Tag(long pVal/*[in]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  unsigned_long __fastcall get_PortId(void)
  {
    unsigned_long pVal;
    OLECHECK(this->get_PortId((unsigned_long*)&pVal));
    return pVal;
  }

  unsigned_long __fastcall get_Baudrate(void)
  {
    unsigned_long pVal;
    OLECHECK(this->get_Baudrate((unsigned_long*)&pVal));
    return pVal;
  }

  Commlib_tlb::EParityMode __fastcall get_ParityMode(void)
  {
    Commlib_tlb::EParityMode pVal;
    OLECHECK(this->get_ParityMode((Commlib_tlb::EParityMode*)&pVal));
    return pVal;
  }

  unsigned_char __fastcall get_ByteSize(void)
  {
    unsigned_char pVal;
    OLECHECK(this->get_ByteSize((unsigned_char*)&pVal));
    return pVal;
  }

  Commlib_tlb::EStopBits __fastcall get_StopBits(void)
  {
    Commlib_tlb::EStopBits pVal;
    OLECHECK(this->get_StopBits((Commlib_tlb::EStopBits*)&pVal));
    return pVal;
  }

  VARIANT_BOOL __fastcall IsActive(void)
  {
    VARIANT_BOOL pbActive;
    OLECHECK(this->IsActive((VARIANT_BOOL*)&pbActive));
    return pbActive;
  }

  long __fastcall get_Tag(void)
  {
    long pVal;
    OLECHECK(this->get_Tag((long*)&pVal));
    return pVal;
  }


  __property   unsigned_long   PortId = {read = get_PortId, write = set_PortId};
  __property   unsigned_long   Baudrate = {read = get_Baudrate, write = set_Baudrate};
  __property   Commlib_tlb::EParityMode ParityMode = {read = get_ParityMode, write = set_ParityMode};
  __property   unsigned_char   ByteSize = {read = get_ByteSize, write = set_ByteSize};
  __property   Commlib_tlb::EStopBits StopBits = {read = get_StopBits, write = set_StopBits};
  __property   long            Tag = {read = get_Tag, write = set_Tag};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: _ITcpClientSocketEvents
// Flags:     (4096) Dispatchable
// GUID:      {23689734-AB52-4C8F-BAF2-796D446D4491}
// *********************************************************************//
interface _ITcpClientSocketEvents : public TDispWrapper<IDispatch>
{
  HRESULT __fastcall OnRead(LPUNKNOWN Sender/*[in]*/, unsigned_char* pbBuffer/*[in]*/, 
                            unsigned_long nLength/*[in]*/)
  {
    _TDispID _dispid(/* OnRead */ DISPID(1));
    TAutoArgs<3> _args;
    _args[1] = Sender /*[VT_UNKNOWN:0]*/;
    _args[2] = pbBuffer /*[VT_UI1:1]*/;
    _args[3] = nLength /*[VT_UI4:0]*/;
    return OleFunction(_dispid, _args);
  }

  HRESULT __fastcall OnStatus(LPUNKNOWN Sender/*[in]*/, unsigned_long nErrorCode/*[in]*/, 
                              BSTR strErrorInfo/*[in]*/)
  {
    _TDispID _dispid(/* OnStatus */ DISPID(2));
    TAutoArgs<3> _args;
    _args[1] = Sender /*[VT_UNKNOWN:0]*/;
    _args[2] = nErrorCode /*[VT_UI4:0]*/;
    _args[3] = strErrorInfo /*[VT_BSTR:0]*/;
    return OleFunction(_dispid, _args);
  }


};
// *********************************************************************//
// Interface: ITcpClientSocket
// Flags:     (4544) Dual NonExtensible OleAutomation Dispatchable
// GUID:      {95340789-564B-4833-A8EC-4D69E58194BD}
// *********************************************************************//
interface ITcpClientSocket  : public IDispatch
{
public:
  // [1] server host name
  virtual HRESULT STDMETHODCALLTYPE get_HostName(BSTR* pVal/*[out,retval]*/) = 0;
  // [1] server host name
  virtual HRESULT STDMETHODCALLTYPE set_HostName(BSTR pVal/*[in]*/) = 0;
  // [2] Server port
  virtual HRESULT STDMETHODCALLTYPE get_Port(unsigned_short* pVal/*[out,retval]*/) = 0;
  // [2] Server port
  virtual HRESULT STDMETHODCALLTYPE set_Port(unsigned_short pVal/*[in]*/) = 0;
  // [3] Connect to host
  virtual HRESULT STDMETHODCALLTYPE Connect(void) = 0;
  // [4] disconnect to server
  virtual HRESULT STDMETHODCALLTYPE Disconnect(void) = 0;
  // [5] Send data
  virtual HRESULT STDMETHODCALLTYPE SendBuffer(unsigned_char* pbBuffer/*[in]*/, 
                                               unsigned_long nSize/*[in]*/) = 0;
  // [6] Tag
  virtual HRESULT STDMETHODCALLTYPE get_Tag(unsigned_long* pVal/*[out,retval]*/) = 0;
  // [6] Tag
  virtual HRESULT STDMETHODCALLTYPE set_Tag(unsigned_long pVal/*[in]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  BSTR __fastcall get_HostName(void)
  {
    BSTR pVal = 0;
    OLECHECK(this->get_HostName((BSTR*)&pVal));
    return pVal;
  }

  unsigned_short __fastcall get_Port(void)
  {
    unsigned_short pVal;
    OLECHECK(this->get_Port((unsigned_short*)&pVal));
    return pVal;
  }

  unsigned_long __fastcall get_Tag(void)
  {
    unsigned_long pVal;
    OLECHECK(this->get_Tag((unsigned_long*)&pVal));
    return pVal;
  }


  __property   BSTR            HostName = {read = get_HostName, write = set_HostName};
  __property   unsigned_short  Port = {read = get_Port, write = set_Port};
  __property   unsigned_long   Tag = {read = get_Tag, write = set_Tag};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)
// *********************************************************************//
// DispIntf:  _ISerialPortEvents
// Flags:     (4096) Dispatchable
// GUID:      {00718A57-81E0-48E9-B9EB-36E40C640180}
// *********************************************************************//
template <class T>
class _ISerialPortEventsDispT : public TAutoDriver<_ISerialPortEvents>
{
public:
  _ISerialPortEventsDispT(){}

  void Attach(LPUNKNOWN punk)
  { m_Dispatch = static_cast<T*>(punk); }

  void            __fastcall OnRead(LPUNKNOWN Sender/*[in]*/, unsigned_char* pbBuffer/*[in]*/, 
                                    unsigned_long nLength/*[in]*/);
  void            __fastcall OnStatus(LPUNKNOWN Sender/*[in]*/, unsigned_long nErrorCode/*[in]*/, 
                                      BSTR strErrorInfo/*[in]*/);

};
typedef _ISerialPortEventsDispT<_ISerialPortEvents> _ISerialPortEventsDisp;

// *********************************************************************//
// SmartIntf: TCOMISerialPort
// Interface: ISerialPort
// *********************************************************************//
template <class T /* ISerialPort */ >
class TCOMISerialPortT : public TComInterface<ISerialPort>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMISerialPortT() {}
  TCOMISerialPortT(ISerialPort *intf, bool addRef = false) : TComInterface<ISerialPort>(intf, addRef) {}
  TCOMISerialPortT(const TCOMISerialPortT& src) : TComInterface<ISerialPort>(src) {}
  TCOMISerialPortT& operator=(const TCOMISerialPortT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall get_PortId(unsigned_long* pVal/*[out,retval]*/);
  unsigned_long   __fastcall get_PortId(void);
  HRESULT         __fastcall set_PortId(unsigned_long pVal/*[in]*/);
  HRESULT         __fastcall get_Baudrate(unsigned_long* pVal/*[out,retval]*/);
  unsigned_long   __fastcall get_Baudrate(void);
  HRESULT         __fastcall set_Baudrate(unsigned_long pVal/*[in]*/);
  HRESULT         __fastcall get_ParityMode(Commlib_tlb::EParityMode* pVal/*[out,retval]*/);
  Commlib_tlb::EParityMode __fastcall get_ParityMode(void);
  HRESULT         __fastcall set_ParityMode(Commlib_tlb::EParityMode pVal/*[in]*/);
  HRESULT         __fastcall get_ByteSize(unsigned_char* pVal/*[out,retval]*/);
  unsigned_char   __fastcall get_ByteSize(void);
  HRESULT         __fastcall set_ByteSize(unsigned_char pVal/*[in]*/);
  HRESULT         __fastcall get_StopBits(Commlib_tlb::EStopBits* pVal/*[out,retval]*/);
  Commlib_tlb::EStopBits __fastcall get_StopBits(void);
  HRESULT         __fastcall set_StopBits(Commlib_tlb::EStopBits pVal/*[in]*/);
  HRESULT         __fastcall Open(void);
  HRESULT         __fastcall Close(void);
  HRESULT         __fastcall SendBuffer(unsigned_char* pbBuffer/*[in]*/, 
                                        unsigned_long nDataLen/*[in]*/);
  HRESULT         __fastcall IsActive(VARIANT_BOOL* pbActive/*[out,retval]*/);
  VARIANT_BOOL    __fastcall IsActive(void);
  HRESULT         __fastcall get_Tag(long* pVal/*[out,retval]*/);
  long            __fastcall get_Tag(void);
  HRESULT         __fastcall set_Tag(long pVal/*[in]*/);

  __property   unsigned_long   PortId = {read = get_PortId, write = set_PortId};
  __property   unsigned_long   Baudrate = {read = get_Baudrate, write = set_Baudrate};
  __property   Commlib_tlb::EParityMode ParityMode = {read = get_ParityMode, write = set_ParityMode};
  __property   unsigned_char   ByteSize = {read = get_ByteSize, write = set_ByteSize};
  __property   Commlib_tlb::EStopBits StopBits = {read = get_StopBits, write = set_StopBits};
  __property   long            Tag = {read = get_Tag, write = set_Tag};
};
typedef TCOMISerialPortT<ISerialPort> TCOMISerialPort;

// *********************************************************************//
// DispIntf:  ISerialPort
// Flags:     (4544) Dual NonExtensible OleAutomation Dispatchable
// GUID:      {FDEC8B1F-1004-4DF5-AAAA-6A99D6AE3C00}
// *********************************************************************//
template<class T>
class ISerialPortDispT : public TAutoDriver<ISerialPort>
{
public:
  ISerialPortDispT(){}

  ISerialPortDispT(ISerialPort *pintf)
  {
    TAutoDriver<ISerialPort>::Bind(pintf, false);
  }

  ISerialPortDispT(ISerialPortPtr pintf)
  {
    TAutoDriver<ISerialPort>::Bind(pintf, true);
  }

  ISerialPortDispT& operator=(ISerialPort *pintf)
  {
    TAutoDriver<ISerialPort>::Bind(pintf, false);
    return *this;
  }

  ISerialPortDispT& operator=(ISerialPortPtr pintf)
  {
    TAutoDriver<ISerialPort>::Bind(pintf, true);
    return *this;
  }

  HRESULT BindDefault()
  {
    return OLECHECK(Bind(CLSID_SerialPort));
  }

  HRESULT BindRunning()
  {
    return BindToActive(CLSID_SerialPort);
  }

  HRESULT         __fastcall get_PortId(unsigned_long* pVal/*[out,retval]*/);
  unsigned_long   __fastcall get_PortId(void);
  HRESULT         __fastcall set_PortId(unsigned_long pVal/*[in]*/);
  HRESULT         __fastcall get_Baudrate(unsigned_long* pVal/*[out,retval]*/);
  unsigned_long   __fastcall get_Baudrate(void);
  HRESULT         __fastcall set_Baudrate(unsigned_long pVal/*[in]*/);
  HRESULT         __fastcall get_ParityMode(Commlib_tlb::EParityMode* pVal/*[out,retval]*/);
  Commlib_tlb::EParityMode __fastcall get_ParityMode(void);
  HRESULT         __fastcall set_ParityMode(Commlib_tlb::EParityMode pVal/*[in]*/);
  HRESULT         __fastcall get_ByteSize(unsigned_char* pVal/*[out,retval]*/);
  unsigned_char   __fastcall get_ByteSize(void);
  HRESULT         __fastcall set_ByteSize(unsigned_char pVal/*[in]*/);
  HRESULT         __fastcall get_StopBits(Commlib_tlb::EStopBits* pVal/*[out,retval]*/);
  Commlib_tlb::EStopBits __fastcall get_StopBits(void);
  HRESULT         __fastcall set_StopBits(Commlib_tlb::EStopBits pVal/*[in]*/);
  HRESULT         __fastcall Open();
  HRESULT         __fastcall Close();
  HRESULT         __fastcall SendBuffer(unsigned_char* pbBuffer/*[in]*/, 
                                        unsigned_long nDataLen/*[in]*/);
  HRESULT         __fastcall IsActive(VARIANT_BOOL* pbActive/*[out,retval]*/);
  VARIANT_BOOL    __fastcall IsActive(void);
  HRESULT         __fastcall get_Tag(long* pVal/*[out,retval]*/);
  long            __fastcall get_Tag(void);
  HRESULT         __fastcall set_Tag(long pVal/*[in]*/);

  __property   unsigned_long   PortId = {read = get_PortId, write = set_PortId};
  __property   unsigned_long   Baudrate = {read = get_Baudrate, write = set_Baudrate};
  __property   Commlib_tlb::EParityMode ParityMode = {read = get_ParityMode, write = set_ParityMode};
  __property   unsigned_char   ByteSize = {read = get_ByteSize, write = set_ByteSize};
  __property   Commlib_tlb::EStopBits StopBits = {read = get_StopBits, write = set_StopBits};
  __property   long            Tag = {read = get_Tag, write = set_Tag};
};
typedef ISerialPortDispT<ISerialPort> ISerialPortDisp;

// *********************************************************************//
// DispIntf:  _ITcpClientSocketEvents
// Flags:     (4096) Dispatchable
// GUID:      {23689734-AB52-4C8F-BAF2-796D446D4491}
// *********************************************************************//
template <class T>
class _ITcpClientSocketEventsDispT : public TAutoDriver<_ITcpClientSocketEvents>
{
public:
  _ITcpClientSocketEventsDispT(){}

  void Attach(LPUNKNOWN punk)
  { m_Dispatch = static_cast<T*>(punk); }

  HRESULT         __fastcall OnRead(LPUNKNOWN Sender/*[in]*/, unsigned_char* pbBuffer/*[in]*/, 
                                    unsigned_long nLength/*[in]*/);
  HRESULT         __fastcall OnStatus(LPUNKNOWN Sender/*[in]*/, unsigned_long nErrorCode/*[in]*/, 
                                      BSTR strErrorInfo/*[in]*/);

};
typedef _ITcpClientSocketEventsDispT<_ITcpClientSocketEvents> _ITcpClientSocketEventsDisp;

// *********************************************************************//
// SmartIntf: TCOMITcpClientSocket
// Interface: ITcpClientSocket
// *********************************************************************//
template <class T /* ITcpClientSocket */ >
class TCOMITcpClientSocketT : public TComInterface<ITcpClientSocket>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMITcpClientSocketT() {}
  TCOMITcpClientSocketT(ITcpClientSocket *intf, bool addRef = false) : TComInterface<ITcpClientSocket>(intf, addRef) {}
  TCOMITcpClientSocketT(const TCOMITcpClientSocketT& src) : TComInterface<ITcpClientSocket>(src) {}
  TCOMITcpClientSocketT& operator=(const TCOMITcpClientSocketT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall get_HostName(BSTR* pVal/*[out,retval]*/);
  BSTR            __fastcall get_HostName(void);
  HRESULT         __fastcall set_HostName(BSTR pVal/*[in]*/);
  HRESULT         __fastcall get_Port(unsigned_short* pVal/*[out,retval]*/);
  unsigned_short  __fastcall get_Port(void);
  HRESULT         __fastcall set_Port(unsigned_short pVal/*[in]*/);
  HRESULT         __fastcall Connect(void);
  HRESULT         __fastcall Disconnect(void);
  HRESULT         __fastcall SendBuffer(unsigned_char* pbBuffer/*[in]*/, unsigned_long nSize/*[in]*/);
  HRESULT         __fastcall get_Tag(unsigned_long* pVal/*[out,retval]*/);
  unsigned_long   __fastcall get_Tag(void);
  HRESULT         __fastcall set_Tag(unsigned_long pVal/*[in]*/);

  __property   BSTR            HostName = {read = get_HostName, write = set_HostName};
  __property   unsigned_short  Port = {read = get_Port, write = set_Port};
  __property   unsigned_long   Tag = {read = get_Tag, write = set_Tag};
};
typedef TCOMITcpClientSocketT<ITcpClientSocket> TCOMITcpClientSocket;

// *********************************************************************//
// DispIntf:  ITcpClientSocket
// Flags:     (4544) Dual NonExtensible OleAutomation Dispatchable
// GUID:      {95340789-564B-4833-A8EC-4D69E58194BD}
// *********************************************************************//
template<class T>
class ITcpClientSocketDispT : public TAutoDriver<ITcpClientSocket>
{
public:
  ITcpClientSocketDispT(){}

  ITcpClientSocketDispT(ITcpClientSocket *pintf)
  {
    TAutoDriver<ITcpClientSocket>::Bind(pintf, false);
  }

  ITcpClientSocketDispT(ITcpClientSocketPtr pintf)
  {
    TAutoDriver<ITcpClientSocket>::Bind(pintf, true);
  }

  ITcpClientSocketDispT& operator=(ITcpClientSocket *pintf)
  {
    TAutoDriver<ITcpClientSocket>::Bind(pintf, false);
    return *this;
  }

  ITcpClientSocketDispT& operator=(ITcpClientSocketPtr pintf)
  {
    TAutoDriver<ITcpClientSocket>::Bind(pintf, true);
    return *this;
  }

  HRESULT BindDefault()
  {
    return OLECHECK(Bind(CLSID_TcpClientSocket));
  }

  HRESULT BindRunning()
  {
    return BindToActive(CLSID_TcpClientSocket);
  }

  HRESULT         __fastcall get_HostName(BSTR* pVal/*[out,retval]*/);
  BSTR            __fastcall get_HostName(void);
  HRESULT         __fastcall set_HostName(BSTR pVal/*[in]*/);
  HRESULT         __fastcall get_Port(unsigned_short* pVal/*[out,retval]*/);
  unsigned_short  __fastcall get_Port(void);
  HRESULT         __fastcall set_Port(unsigned_short pVal/*[in]*/);
  HRESULT         __fastcall Connect();
  HRESULT         __fastcall Disconnect();
  HRESULT         __fastcall SendBuffer(unsigned_char* pbBuffer/*[in]*/, unsigned_long nSize/*[in]*/);
  HRESULT         __fastcall get_Tag(unsigned_long* pVal/*[out,retval]*/);
  unsigned_long   __fastcall get_Tag(void);
  HRESULT         __fastcall set_Tag(unsigned_long pVal/*[in]*/);

  __property   BSTR            HostName = {read = get_HostName, write = set_HostName};
  __property   unsigned_short  Port = {read = get_Port, write = set_Port};
  __property   unsigned_long   Tag = {read = get_Tag, write = set_Tag};
};
typedef ITcpClientSocketDispT<ITcpClientSocket> ITcpClientSocketDisp;

// *********************************************************************//
// DispIntf:  _ISerialPortEvents
// Flags:     (4096) Dispatchable
// GUID:      {00718A57-81E0-48E9-B9EB-36E40C640180}
// *********************************************************************//
template <class T> void __fastcall
_ISerialPortEventsDispT<T>::OnRead(LPUNKNOWN Sender/*[in]*/, unsigned_char* pbBuffer/*[in]*/, 
                                   unsigned_long nLength/*[in]*/)
{
  _TDispID _dispid(/* OnRead */ DISPID(1));
  TAutoArgs<3> _args;
  _args[1] = Sender /*[VT_UNKNOWN:0]*/;
  _args[2] = pbBuffer /*[VT_UI1:1]*/;
  _args[3] = nLength /*[VT_UI4:0]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISerialPortEventsDispT<T>::OnStatus(LPUNKNOWN Sender/*[in]*/, unsigned_long nErrorCode/*[in]*/, 
                                     BSTR strErrorInfo/*[in]*/)
{
  _TDispID _dispid(/* OnStatus */ DISPID(2));
  TAutoArgs<3> _args;
  _args[1] = Sender /*[VT_UNKNOWN:0]*/;
  _args[2] = nErrorCode /*[VT_UI4:0]*/;
  _args[3] = strErrorInfo /*[VT_BSTR:0]*/;
  OleProcedure(_dispid, _args);
}

// *********************************************************************//
// SmartIntf: TCOMISerialPort
// Interface: ISerialPort
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMISerialPortT<T>::get_PortId(unsigned_long* pVal/*[out,retval]*/)
{
  return (*this)->get_PortId(pVal);
}

template <class T> unsigned_long __fastcall
TCOMISerialPortT<T>::get_PortId(void)
{
  unsigned_long pVal;
  OLECHECK(this->get_PortId((unsigned_long*)&pVal));
  return pVal;
}

template <class T> HRESULT __fastcall
TCOMISerialPortT<T>::set_PortId(unsigned_long pVal/*[in]*/)
{
  return (*this)->set_PortId(pVal);
}

template <class T> HRESULT __fastcall
TCOMISerialPortT<T>::get_Baudrate(unsigned_long* pVal/*[out,retval]*/)
{
  return (*this)->get_Baudrate(pVal);
}

template <class T> unsigned_long __fastcall
TCOMISerialPortT<T>::get_Baudrate(void)
{
  unsigned_long pVal;
  OLECHECK(this->get_Baudrate((unsigned_long*)&pVal));
  return pVal;
}

template <class T> HRESULT __fastcall
TCOMISerialPortT<T>::set_Baudrate(unsigned_long pVal/*[in]*/)
{
  return (*this)->set_Baudrate(pVal);
}

template <class T> HRESULT __fastcall
TCOMISerialPortT<T>::get_ParityMode(Commlib_tlb::EParityMode* pVal/*[out,retval]*/)
{
  return (*this)->get_ParityMode(pVal);
}

template <class T> Commlib_tlb::EParityMode __fastcall
TCOMISerialPortT<T>::get_ParityMode(void)
{
  Commlib_tlb::EParityMode pVal;
  OLECHECK(this->get_ParityMode((Commlib_tlb::EParityMode*)&pVal));
  return pVal;
}

template <class T> HRESULT __fastcall
TCOMISerialPortT<T>::set_ParityMode(Commlib_tlb::EParityMode pVal/*[in]*/)
{
  return (*this)->set_ParityMode(pVal);
}

template <class T> HRESULT __fastcall
TCOMISerialPortT<T>::get_ByteSize(unsigned_char* pVal/*[out,retval]*/)
{
  return (*this)->get_ByteSize(pVal);
}

template <class T> unsigned_char __fastcall
TCOMISerialPortT<T>::get_ByteSize(void)
{
  unsigned_char pVal;
  OLECHECK(this->get_ByteSize((unsigned_char*)&pVal));
  return pVal;
}

template <class T> HRESULT __fastcall
TCOMISerialPortT<T>::set_ByteSize(unsigned_char pVal/*[in]*/)
{
  return (*this)->set_ByteSize(pVal);
}

template <class T> HRESULT __fastcall
TCOMISerialPortT<T>::get_StopBits(Commlib_tlb::EStopBits* pVal/*[out,retval]*/)
{
  return (*this)->get_StopBits(pVal);
}

template <class T> Commlib_tlb::EStopBits __fastcall
TCOMISerialPortT<T>::get_StopBits(void)
{
  Commlib_tlb::EStopBits pVal;
  OLECHECK(this->get_StopBits((Commlib_tlb::EStopBits*)&pVal));
  return pVal;
}

template <class T> HRESULT __fastcall
TCOMISerialPortT<T>::set_StopBits(Commlib_tlb::EStopBits pVal/*[in]*/)
{
  return (*this)->set_StopBits(pVal);
}

template <class T> HRESULT __fastcall
TCOMISerialPortT<T>::Open(void)
{
  return (*this)->Open();
}

template <class T> HRESULT __fastcall
TCOMISerialPortT<T>::Close(void)
{
  return (*this)->Close();
}

template <class T> HRESULT __fastcall
TCOMISerialPortT<T>::SendBuffer(unsigned_char* pbBuffer/*[in]*/, unsigned_long nDataLen/*[in]*/)
{
  return (*this)->SendBuffer(pbBuffer, nDataLen);
}

template <class T> HRESULT __fastcall
TCOMISerialPortT<T>::IsActive(VARIANT_BOOL* pbActive/*[out,retval]*/)
{
  return (*this)->IsActive(pbActive);
}

template <class T> VARIANT_BOOL __fastcall
TCOMISerialPortT<T>::IsActive(void)
{
  VARIANT_BOOL pbActive;
  OLECHECK(this->IsActive((VARIANT_BOOL*)&pbActive));
  return pbActive;
}

template <class T> HRESULT __fastcall
TCOMISerialPortT<T>::get_Tag(long* pVal/*[out,retval]*/)
{
  return (*this)->get_Tag(pVal);
}

template <class T> long __fastcall
TCOMISerialPortT<T>::get_Tag(void)
{
  long pVal;
  OLECHECK(this->get_Tag((long*)&pVal));
  return pVal;
}

template <class T> HRESULT __fastcall
TCOMISerialPortT<T>::set_Tag(long pVal/*[in]*/)
{
  return (*this)->set_Tag(pVal);
}

// *********************************************************************//
// DispIntf:  ISerialPort
// Flags:     (4544) Dual NonExtensible OleAutomation Dispatchable
// GUID:      {FDEC8B1F-1004-4DF5-AAAA-6A99D6AE3C00}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISerialPortDispT<T>::get_PortId(unsigned_long* pVal/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("PortId"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pVal /*[VT_UI4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> unsigned_long __fastcall
ISerialPortDispT<T>::get_PortId(void)
{
  unsigned_long pVal;
  this->get_PortId((unsigned_long*)&pVal);
  return pVal;
}

template <class T> HRESULT __fastcall
ISerialPortDispT<T>::set_PortId(unsigned_long pVal/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("PortId"), DISPID(1));
  TAutoArgs<1> _args;
  _args[1] = pVal /*[VT_UI4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISerialPortDispT<T>::get_Baudrate(unsigned_long* pVal/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Baudrate"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pVal /*[VT_UI4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> unsigned_long __fastcall
ISerialPortDispT<T>::get_Baudrate(void)
{
  unsigned_long pVal;
  this->get_Baudrate((unsigned_long*)&pVal);
  return pVal;
}

template <class T> HRESULT __fastcall
ISerialPortDispT<T>::set_Baudrate(unsigned_long pVal/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Baudrate"), DISPID(2));
  TAutoArgs<1> _args;
  _args[1] = pVal /*[VT_UI4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISerialPortDispT<T>::get_ParityMode(Commlib_tlb::EParityMode* pVal/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("ParityMode"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)pVal /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Commlib_tlb::EParityMode __fastcall
ISerialPortDispT<T>::get_ParityMode(void)
{
  Commlib_tlb::EParityMode pVal;
  this->get_ParityMode((Commlib_tlb::EParityMode*)&pVal);
  return pVal;
}

template <class T> HRESULT __fastcall
ISerialPortDispT<T>::set_ParityMode(Commlib_tlb::EParityMode pVal/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("ParityMode"), DISPID(3));
  TAutoArgs<1> _args;
  _args[1] = (int)pVal /*[VT_USERDEFINED:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISerialPortDispT<T>::get_ByteSize(unsigned_char* pVal/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("ByteSize"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pVal /*[VT_UI1:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> unsigned_char __fastcall
ISerialPortDispT<T>::get_ByteSize(void)
{
  unsigned_char pVal;
  this->get_ByteSize((unsigned_char*)&pVal);
  return pVal;
}

template <class T> HRESULT __fastcall
ISerialPortDispT<T>::set_ByteSize(unsigned_char pVal/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("ByteSize"), DISPID(4));
  TAutoArgs<1> _args;
  _args[1] = pVal /*[VT_UI1:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISerialPortDispT<T>::get_StopBits(Commlib_tlb::EStopBits* pVal/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("StopBits"), DISPID(5));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)pVal /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Commlib_tlb::EStopBits __fastcall
ISerialPortDispT<T>::get_StopBits(void)
{
  Commlib_tlb::EStopBits pVal;
  this->get_StopBits((Commlib_tlb::EStopBits*)&pVal);
  return pVal;
}

template <class T> HRESULT __fastcall
ISerialPortDispT<T>::set_StopBits(Commlib_tlb::EStopBits pVal/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("StopBits"), DISPID(5));
  TAutoArgs<1> _args;
  _args[1] = (int)pVal /*[VT_USERDEFINED:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISerialPortDispT<T>::Open()
{
  _TDispID _dispid(*this, OLETEXT("Open"), DISPID(6));
  return OleFunction(_dispid);
}

template <class T> HRESULT __fastcall
ISerialPortDispT<T>::Close()
{
  _TDispID _dispid(*this, OLETEXT("Close"), DISPID(7));
  return OleFunction(_dispid);
}

template <class T> HRESULT __fastcall
ISerialPortDispT<T>::SendBuffer(unsigned_char* pbBuffer/*[in]*/, unsigned_long nDataLen/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("SendBuffer"), DISPID(8));
  TAutoArgs<2> _args;
  _args[1] = pbBuffer /*[VT_UI1:1]*/;
  _args[2] = nDataLen /*[VT_UI4:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISerialPortDispT<T>::IsActive(VARIANT_BOOL* pbActive/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("IsActive"), DISPID(9));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pbActive /*[VT_BOOL:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
ISerialPortDispT<T>::IsActive(void)
{
  VARIANT_BOOL pbActive;
  this->IsActive((VARIANT_BOOL*)&pbActive);
  return pbActive;
}

template <class T> HRESULT __fastcall
ISerialPortDispT<T>::get_Tag(long* pVal/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Tag"), DISPID(10));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pVal /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISerialPortDispT<T>::get_Tag(void)
{
  long pVal;
  this->get_Tag((long*)&pVal);
  return pVal;
}

template <class T> HRESULT __fastcall
ISerialPortDispT<T>::set_Tag(long pVal/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Tag"), DISPID(10));
  TAutoArgs<1> _args;
  _args[1] = pVal /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

// *********************************************************************//
// DispIntf:  _ITcpClientSocketEvents
// Flags:     (4096) Dispatchable
// GUID:      {23689734-AB52-4C8F-BAF2-796D446D4491}
// *********************************************************************//
template <class T> HRESULT __fastcall
_ITcpClientSocketEventsDispT<T>::OnRead(LPUNKNOWN Sender/*[in]*/, unsigned_char* pbBuffer/*[in]*/, 
                                        unsigned_long nLength/*[in]*/)
{
  _TDispID _dispid(/* OnRead */ DISPID(1));
  TAutoArgs<3> _args;
  _args[1] = Sender /*[VT_UNKNOWN:0]*/;
  _args[2] = pbBuffer /*[VT_UI1:1]*/;
  _args[3] = nLength /*[VT_UI4:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
_ITcpClientSocketEventsDispT<T>::OnStatus(LPUNKNOWN Sender/*[in]*/, unsigned_long nErrorCode/*[in]*/
                                          , BSTR strErrorInfo/*[in]*/)
{
  _TDispID _dispid(/* OnStatus */ DISPID(2));
  TAutoArgs<3> _args;
  _args[1] = Sender /*[VT_UNKNOWN:0]*/;
  _args[2] = nErrorCode /*[VT_UI4:0]*/;
  _args[3] = strErrorInfo /*[VT_BSTR:0]*/;
  return OleFunction(_dispid, _args);
}

// *********************************************************************//
// SmartIntf: TCOMITcpClientSocket
// Interface: ITcpClientSocket
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMITcpClientSocketT<T>::get_HostName(BSTR* pVal/*[out,retval]*/)
{
  return (*this)->get_HostName(pVal);
}

template <class T> BSTR __fastcall
TCOMITcpClientSocketT<T>::get_HostName(void)
{
  BSTR pVal = 0;
  OLECHECK(this->get_HostName((BSTR*)&pVal));
  return pVal;
}

template <class T> HRESULT __fastcall
TCOMITcpClientSocketT<T>::set_HostName(BSTR pVal/*[in]*/)
{
  return (*this)->set_HostName(pVal);
}

template <class T> HRESULT __fastcall
TCOMITcpClientSocketT<T>::get_Port(unsigned_short* pVal/*[out,retval]*/)
{
  return (*this)->get_Port(pVal);
}

template <class T> unsigned_short __fastcall
TCOMITcpClientSocketT<T>::get_Port(void)
{
  unsigned_short pVal;
  OLECHECK(this->get_Port((unsigned_short*)&pVal));
  return pVal;
}

template <class T> HRESULT __fastcall
TCOMITcpClientSocketT<T>::set_Port(unsigned_short pVal/*[in]*/)
{
  return (*this)->set_Port(pVal);
}

template <class T> HRESULT __fastcall
TCOMITcpClientSocketT<T>::Connect(void)
{
  return (*this)->Connect();
}

template <class T> HRESULT __fastcall
TCOMITcpClientSocketT<T>::Disconnect(void)
{
  return (*this)->Disconnect();
}

template <class T> HRESULT __fastcall
TCOMITcpClientSocketT<T>::SendBuffer(unsigned_char* pbBuffer/*[in]*/, unsigned_long nSize/*[in]*/)
{
  return (*this)->SendBuffer(pbBuffer, nSize);
}

template <class T> HRESULT __fastcall
TCOMITcpClientSocketT<T>::get_Tag(unsigned_long* pVal/*[out,retval]*/)
{
  return (*this)->get_Tag(pVal);
}

template <class T> unsigned_long __fastcall
TCOMITcpClientSocketT<T>::get_Tag(void)
{
  unsigned_long pVal;
  OLECHECK(this->get_Tag((unsigned_long*)&pVal));
  return pVal;
}

template <class T> HRESULT __fastcall
TCOMITcpClientSocketT<T>::set_Tag(unsigned_long pVal/*[in]*/)
{
  return (*this)->set_Tag(pVal);
}

// *********************************************************************//
// DispIntf:  ITcpClientSocket
// Flags:     (4544) Dual NonExtensible OleAutomation Dispatchable
// GUID:      {95340789-564B-4833-A8EC-4D69E58194BD}
// *********************************************************************//
template <class T> HRESULT __fastcall
ITcpClientSocketDispT<T>::get_HostName(BSTR* pVal/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("HostName"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pVal /*[VT_BSTR:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> BSTR __fastcall
ITcpClientSocketDispT<T>::get_HostName(void)
{
  BSTR pVal;
  this->get_HostName((BSTR*)&pVal);
  return pVal;
}

template <class T> HRESULT __fastcall
ITcpClientSocketDispT<T>::set_HostName(BSTR pVal/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("HostName"), DISPID(1));
  TAutoArgs<1> _args;
  _args[1] = pVal /*[VT_BSTR:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ITcpClientSocketDispT<T>::get_Port(unsigned_short* pVal/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Port"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pVal /*[VT_UI2:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> unsigned_short __fastcall
ITcpClientSocketDispT<T>::get_Port(void)
{
  unsigned_short pVal;
  this->get_Port((unsigned_short*)&pVal);
  return pVal;
}

template <class T> HRESULT __fastcall
ITcpClientSocketDispT<T>::set_Port(unsigned_short pVal/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Port"), DISPID(2));
  TAutoArgs<1> _args;
  _args[1] = pVal /*[VT_UI2:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ITcpClientSocketDispT<T>::Connect()
{
  _TDispID _dispid(*this, OLETEXT("Connect"), DISPID(3));
  return OleFunction(_dispid);
}

template <class T> HRESULT __fastcall
ITcpClientSocketDispT<T>::Disconnect()
{
  _TDispID _dispid(*this, OLETEXT("Disconnect"), DISPID(4));
  return OleFunction(_dispid);
}

template <class T> HRESULT __fastcall
ITcpClientSocketDispT<T>::SendBuffer(unsigned_char* pbBuffer/*[in]*/, unsigned_long nSize/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("SendBuffer"), DISPID(5));
  TAutoArgs<2> _args;
  _args[1] = pbBuffer /*[VT_UI1:1]*/;
  _args[2] = nSize /*[VT_UI4:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ITcpClientSocketDispT<T>::get_Tag(unsigned_long* pVal/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Tag"), DISPID(6));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pVal /*[VT_UI4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> unsigned_long __fastcall
ITcpClientSocketDispT<T>::get_Tag(void)
{
  unsigned_long pVal;
  this->get_Tag((unsigned_long*)&pVal);
  return pVal;
}

template <class T> HRESULT __fastcall
ITcpClientSocketDispT<T>::set_Tag(unsigned_long pVal/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Tag"), DISPID(6));
  TAutoArgs<1> _args;
  _args[1] = pVal /*[VT_UI4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

// *********************************************************************//
// The following typedefs expose classes (named CoCoClassName) that       
// provide static Create() and CreateRemote(LPWSTR machineName) methods   
// for creating an instance of an exposed object. These functions can     
// be used by client wishing to automate CoClasses exposed by this        
// typelibrary.                                                           
// *********************************************************************//

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SerialPort
// Interface: TCOMISerialPort
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISerialPort, ISerialPort, &CLSID_SerialPort, &IID_ISerialPort> CoSerialPort;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : TcpClientSocket
// Interface: TCOMITcpClientSocket
// *********************************************************************//
typedef TCoClassCreatorT<TCOMITcpClientSocket, ITcpClientSocket, &CLSID_TcpClientSocket, &IID_ITcpClientSocket> CoTcpClientSocket;
#endif  //   __TLB_NO_INTERFACE_WRAPPERS


#if !defined(__TLB_NO_EVENT_WRAPPERS) && defined(USING_ATLVCL)
// *********************************************************************//
// CONNECTIONPOINT/EVENT PROXY
// CoClass         : SerialPort
// Event Interface : _ISerialPortEvents
// *********************************************************************//
template <class T>
class TEvents_SerialPort : public IConnectionPointImpl<T,
                                                 &DIID__ISerialPortEvents,
#if !defined(_TLB_DYNAMIC_CONNECTIONPOINT_ARRAY)
                                                 CComUnkArray<CONNECTIONPOINT_ARRAY_SIZE> >
#else
                                                 CComDynamicArray>
#endif
{
public:
  void            Fire_OnRead(LPUNKNOWN Sender, unsigned_char* pbBuffer, unsigned_long nLength);
  void            Fire_OnStatus(LPUNKNOWN Sender, unsigned_long nErrorCode, BSTR strErrorInfo);
protected:
  _ISerialPortEventsDisp m_EventIntfObj;
};

template <class T> void
TEvents_SerialPort<T>::Fire_OnRead(LPUNKNOWN Sender, unsigned_char* pbBuffer, unsigned_long nLength)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.OnRead(Sender, pbBuffer, nLength);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SerialPort<T>::Fire_OnStatus(LPUNKNOWN Sender, unsigned_long nErrorCode, BSTR strErrorInfo)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.OnStatus(Sender, nErrorCode, strErrorInfo);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

// *********************************************************************//
// CONNECTIONPOINT/EVENT PROXY
// CoClass         : TcpClientSocket
// Event Interface : _ITcpClientSocketEvents
// *********************************************************************//
template <class T>
class TEvents_TcpClientSocket : public IConnectionPointImpl<T,
                                                 &DIID__ITcpClientSocketEvents,
#if !defined(_TLB_DYNAMIC_CONNECTIONPOINT_ARRAY)
                                                 CComUnkArray<CONNECTIONPOINT_ARRAY_SIZE> >
#else
                                                 CComDynamicArray>
#endif
{
public:
  HRESULT         Fire_OnRead(LPUNKNOWN Sender, unsigned_char* pbBuffer, unsigned_long nLength);
  HRESULT         Fire_OnStatus(LPUNKNOWN Sender, unsigned_long nErrorCode, BSTR strErrorInfo);
protected:
  _ITcpClientSocketEventsDisp m_EventIntfObj;
};

template <class T> HRESULT
TEvents_TcpClientSocket<T>::Fire_OnRead(LPUNKNOWN Sender, unsigned_char* pbBuffer, 
                                        unsigned_long nLength)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.OnRead(Sender, pbBuffer, nLength);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
  return S_OK;
}

template <class T> HRESULT
TEvents_TcpClientSocket<T>::Fire_OnStatus(LPUNKNOWN Sender, unsigned_long nErrorCode, 
                                          BSTR strErrorInfo)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.OnStatus(Sender, nErrorCode, strErrorInfo);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
  return S_OK;
}

#endif    //   __TLB_NO_EVENT_WRAPPERS

#if !defined(__TLB_NO_EVENT_WRAPPERS) && defined(USING_DAX)
// *********************************************************************//
// CONNECTIONPOINT/EVENT PROXY
// CoClass         : SerialPort
// Event Interface : _ISerialPortEvents
// *********************************************************************//
template <typename T>
class ISerialPort_EventsDispatcher : public IUnknown
{
public:
  void Fire_OnRead(LPUNKNOWN Sender, unsigned_char* pbBuffer, unsigned_long nLength)
  {
    _ISerialPortEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.OnRead(Sender, pbBuffer, nLength);
      }
    }
  }

  void Fire_OnStatus(LPUNKNOWN Sender, unsigned_long nErrorCode, BSTR strErrorInfo)
  {
    _ISerialPortEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.OnStatus(Sender, nErrorCode, strErrorInfo);
      }
    }
  }

};

// *********************************************************************//
// CONNECTIONPOINT/EVENT PROXY
// CoClass         : TcpClientSocket
// Event Interface : _ITcpClientSocketEvents
// *********************************************************************//
template <typename T>
class ITcpClientSocket_EventsDispatcher : public IUnknown
{
public:
  HRESULT Fire_OnRead(LPUNKNOWN Sender, unsigned_char* pbBuffer, unsigned_long nLength)
  {
    _ITcpClientSocketEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.OnRead(Sender, pbBuffer, nLength);
      }
    }
    return S_OK;
  }

  HRESULT Fire_OnStatus(LPUNKNOWN Sender, unsigned_long nErrorCode, BSTR strErrorInfo)
  {
    _ITcpClientSocketEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.OnStatus(Sender, nErrorCode, strErrorInfo);
      }
    }
    return S_OK;
  }

};

#endif    //   __TLB_NO_EVENT_WRAPPERS

};     // namespace Commlib_tlb

#if !defined(NO_IMPLICIT_NAMESPACE_USE)
using  namespace Commlib_tlb;
#endif

#pragma option pop

#endif // CommLib_TLBH
